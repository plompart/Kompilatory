Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> anything_list
Rule 2     program -> <empty>
Rule 3     anything_list -> anything_list anything
Rule 4     anything_list -> anything
Rule 5     anything -> declaration
Rule 6     anything -> fundef
Rule 7     anything -> instruction
Rule 8     declaration -> TYPE inits ;
Rule 9     declaration -> error ;
Rule 10    inits -> inits , init
Rule 11    inits -> init
Rule 12    init -> ID = expression
Rule 13    instruction -> print_instr
Rule 14    instruction -> labeled_instr
Rule 15    instruction -> assignment
Rule 16    instruction -> choice_instr
Rule 17    instruction -> while_instr
Rule 18    instruction -> repeat_instr
Rule 19    instruction -> return_instr
Rule 20    instruction -> break_instr
Rule 21    instruction -> continue_instr
Rule 22    instruction -> compound_instr
Rule 23    instruction -> expression ;
Rule 24    print_instr -> PRINT expression ;
Rule 25    print_instr -> PRINT error ;
Rule 26    labeled_instr -> ID : instruction
Rule 27    assignment -> ID = expression ;
Rule 28    choice_instr -> IF ( condition ) instruction
Rule 29    choice_instr -> IF ( condition ) instruction ELSE instruction
Rule 30    choice_instr -> IF ( error ) instruction
Rule 31    choice_instr -> IF ( error ) instruction ELSE instruction
Rule 32    while_instr -> WHILE ( condition ) instruction
Rule 33    while_instr -> WHILE ( error ) instruction
Rule 34    repeat_instr -> REPEAT anything_list UNTIL condition ;
Rule 35    return_instr -> RETURN expression ;
Rule 36    continue_instr -> CONTINUE ;
Rule 37    break_instr -> BREAK ;
Rule 38    compound_instr -> { anything_list }
Rule 39    condition -> expression
Rule 40    const -> INTEGER
Rule 41    const -> FLOAT
Rule 42    const -> STRING
Rule 43    expression -> ID
Rule 44    expression -> const
Rule 45    expression -> expression + expression
Rule 46    expression -> expression - expression
Rule 47    expression -> expression * expression
Rule 48    expression -> expression / expression
Rule 49    expression -> expression % expression
Rule 50    expression -> expression | expression
Rule 51    expression -> expression & expression
Rule 52    expression -> expression ^ expression
Rule 53    expression -> expression AND expression
Rule 54    expression -> expression OR expression
Rule 55    expression -> expression SHL expression
Rule 56    expression -> expression SHR expression
Rule 57    expression -> expression EQ expression
Rule 58    expression -> expression NEQ expression
Rule 59    expression -> expression > expression
Rule 60    expression -> expression < expression
Rule 61    expression -> expression LE expression
Rule 62    expression -> expression GE expression
Rule 63    expression -> ( expression )
Rule 64    expression -> ( error )
Rule 65    expression -> ID ( expr_list_or_empty )
Rule 66    expression -> ID ( error )
Rule 67    expr_list_or_empty -> expr_list
Rule 68    expr_list_or_empty -> <empty>
Rule 69    expr_list -> expr_list , expression
Rule 70    expr_list -> expression
Rule 71    fundef -> TYPE ID ( args_list_or_empty ) compound_instr
Rule 72    args_list_or_empty -> args_list
Rule 73    args_list_or_empty -> <empty>
Rule 74    args_list -> args_list , arg
Rule 75    args_list -> arg
Rule 76    arg -> TYPE ID

Terminals, with rules where they appear

%                    : 49
&                    : 51
(                    : 28 29 30 31 32 33 63 64 65 66 71
)                    : 28 29 30 31 32 33 63 64 65 66 71
*                    : 47
+                    : 45
,                    : 10 69 74
-                    : 46
/                    : 48
:                    : 26
;                    : 8 9 23 24 25 27 34 35 36 37
<                    : 60
=                    : 12 27
>                    : 59
AND                  : 53
BREAK                : 37
CONTINUE             : 36
ELSE                 : 29 31
EQ                   : 57
FLOAT                : 41
GE                   : 62
ID                   : 12 26 27 43 65 66 71 76
IF                   : 28 29 30 31
INTEGER              : 40
LE                   : 61
NEQ                  : 58
OR                   : 54
PRINT                : 24 25
REPEAT               : 34
RETURN               : 35
SHL                  : 55
SHR                  : 56
STRING               : 42
TYPE                 : 8 71 76
UNTIL                : 34
WHILE                : 32 33
^                    : 52
error                : 9 25 30 31 33 64 66
{                    : 38
|                    : 50
}                    : 38

Nonterminals, with rules where they appear

anything             : 3 4
anything_list        : 1 3 34 38
arg                  : 74 75
args_list            : 72 74
args_list_or_empty   : 71
assignment           : 15
break_instr          : 20
choice_instr         : 16
compound_instr       : 22 71
condition            : 28 29 32 34
const                : 44
continue_instr       : 21
declaration          : 5
expr_list            : 67 69
expr_list_or_empty   : 65
expression           : 12 23 24 27 35 39 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 69 70
fundef               : 6
init                 : 10 11
inits                : 8 10
instruction          : 7 26 28 29 29 30 31 31 32 33
labeled_instr        : 14
print_instr          : 13
program              : 0
repeat_instr         : 18
return_instr         : 19
while_instr          : 17

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . anything_list
    (2) program -> .
    (3) anything_list -> . anything_list anything
    (4) anything_list -> . anything
    (5) anything -> . declaration
    (6) anything -> . fundef
    (7) anything -> . instruction
    (8) declaration -> . TYPE inits ;
    (9) declaration -> . error ;
    (71) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expression ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT anything_list UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { anything_list }
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    $end            reduce using rule 2 (program -> .)
    TYPE            shift and go to state 33
    error           shift and go to state 31
    PRINT           shift and go to state 4
    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 5
    REPEAT          shift and go to state 15
    RETURN          shift and go to state 2
    BREAK           shift and go to state 14
    CONTINUE        shift and go to state 29
    {               shift and go to state 32
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    choice_instr                   shift and go to state 3
    repeat_instr                   shift and go to state 6
    return_instr                   shift and go to state 7
    const                          shift and go to state 8
    continue_instr                 shift and go to state 10
    while_instr                    shift and go to state 11
    program                        shift and go to state 12
    assignment                     shift and go to state 17
    labeled_instr                  shift and go to state 18
    compound_instr                 shift and go to state 19
    declaration                    shift and go to state 20
    anything                       shift and go to state 23
    break_instr                    shift and go to state 24
    instruction                    shift and go to state 25
    fundef                         shift and go to state 26
    anything_list                  shift and go to state 27
    print_instr                    shift and go to state 28
    expression                     shift and go to state 30

state 1

    (41) const -> FLOAT .

    +               reduce using rule 41 (const -> FLOAT .)
    -               reduce using rule 41 (const -> FLOAT .)
    *               reduce using rule 41 (const -> FLOAT .)
    /               reduce using rule 41 (const -> FLOAT .)
    %               reduce using rule 41 (const -> FLOAT .)
    |               reduce using rule 41 (const -> FLOAT .)
    &               reduce using rule 41 (const -> FLOAT .)
    ^               reduce using rule 41 (const -> FLOAT .)
    AND             reduce using rule 41 (const -> FLOAT .)
    OR              reduce using rule 41 (const -> FLOAT .)
    SHL             reduce using rule 41 (const -> FLOAT .)
    SHR             reduce using rule 41 (const -> FLOAT .)
    EQ              reduce using rule 41 (const -> FLOAT .)
    NEQ             reduce using rule 41 (const -> FLOAT .)
    >               reduce using rule 41 (const -> FLOAT .)
    <               reduce using rule 41 (const -> FLOAT .)
    LE              reduce using rule 41 (const -> FLOAT .)
    GE              reduce using rule 41 (const -> FLOAT .)
    )               reduce using rule 41 (const -> FLOAT .)
    ;               reduce using rule 41 (const -> FLOAT .)
    ,               reduce using rule 41 (const -> FLOAT .)


state 2

    (35) return_instr -> RETURN . expression ;
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 35

state 3

    (16) instruction -> choice_instr .

    TYPE            reduce using rule 16 (instruction -> choice_instr .)
    error           reduce using rule 16 (instruction -> choice_instr .)
    PRINT           reduce using rule 16 (instruction -> choice_instr .)
    ID              reduce using rule 16 (instruction -> choice_instr .)
    IF              reduce using rule 16 (instruction -> choice_instr .)
    WHILE           reduce using rule 16 (instruction -> choice_instr .)
    REPEAT          reduce using rule 16 (instruction -> choice_instr .)
    RETURN          reduce using rule 16 (instruction -> choice_instr .)
    BREAK           reduce using rule 16 (instruction -> choice_instr .)
    CONTINUE        reduce using rule 16 (instruction -> choice_instr .)
    {               reduce using rule 16 (instruction -> choice_instr .)
    (               reduce using rule 16 (instruction -> choice_instr .)
    INTEGER         reduce using rule 16 (instruction -> choice_instr .)
    FLOAT           reduce using rule 16 (instruction -> choice_instr .)
    STRING          reduce using rule 16 (instruction -> choice_instr .)
    $end            reduce using rule 16 (instruction -> choice_instr .)
    UNTIL           reduce using rule 16 (instruction -> choice_instr .)
    }               reduce using rule 16 (instruction -> choice_instr .)
    ELSE            reduce using rule 16 (instruction -> choice_instr .)


state 4

    (24) print_instr -> PRINT . expression ;
    (25) print_instr -> PRINT . error ;
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    error           shift and go to state 36
    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 37

state 5

    (32) while_instr -> WHILE . ( condition ) instruction
    (33) while_instr -> WHILE . ( error ) instruction

    (               shift and go to state 38


state 6

    (18) instruction -> repeat_instr .

    TYPE            reduce using rule 18 (instruction -> repeat_instr .)
    error           reduce using rule 18 (instruction -> repeat_instr .)
    PRINT           reduce using rule 18 (instruction -> repeat_instr .)
    ID              reduce using rule 18 (instruction -> repeat_instr .)
    IF              reduce using rule 18 (instruction -> repeat_instr .)
    WHILE           reduce using rule 18 (instruction -> repeat_instr .)
    REPEAT          reduce using rule 18 (instruction -> repeat_instr .)
    RETURN          reduce using rule 18 (instruction -> repeat_instr .)
    BREAK           reduce using rule 18 (instruction -> repeat_instr .)
    CONTINUE        reduce using rule 18 (instruction -> repeat_instr .)
    {               reduce using rule 18 (instruction -> repeat_instr .)
    (               reduce using rule 18 (instruction -> repeat_instr .)
    INTEGER         reduce using rule 18 (instruction -> repeat_instr .)
    FLOAT           reduce using rule 18 (instruction -> repeat_instr .)
    STRING          reduce using rule 18 (instruction -> repeat_instr .)
    $end            reduce using rule 18 (instruction -> repeat_instr .)
    UNTIL           reduce using rule 18 (instruction -> repeat_instr .)
    }               reduce using rule 18 (instruction -> repeat_instr .)
    ELSE            reduce using rule 18 (instruction -> repeat_instr .)


state 7

    (19) instruction -> return_instr .

    TYPE            reduce using rule 19 (instruction -> return_instr .)
    error           reduce using rule 19 (instruction -> return_instr .)
    PRINT           reduce using rule 19 (instruction -> return_instr .)
    ID              reduce using rule 19 (instruction -> return_instr .)
    IF              reduce using rule 19 (instruction -> return_instr .)
    WHILE           reduce using rule 19 (instruction -> return_instr .)
    REPEAT          reduce using rule 19 (instruction -> return_instr .)
    RETURN          reduce using rule 19 (instruction -> return_instr .)
    BREAK           reduce using rule 19 (instruction -> return_instr .)
    CONTINUE        reduce using rule 19 (instruction -> return_instr .)
    {               reduce using rule 19 (instruction -> return_instr .)
    (               reduce using rule 19 (instruction -> return_instr .)
    INTEGER         reduce using rule 19 (instruction -> return_instr .)
    FLOAT           reduce using rule 19 (instruction -> return_instr .)
    STRING          reduce using rule 19 (instruction -> return_instr .)
    $end            reduce using rule 19 (instruction -> return_instr .)
    UNTIL           reduce using rule 19 (instruction -> return_instr .)
    }               reduce using rule 19 (instruction -> return_instr .)
    ELSE            reduce using rule 19 (instruction -> return_instr .)


state 8

    (44) expression -> const .

    +               reduce using rule 44 (expression -> const .)
    -               reduce using rule 44 (expression -> const .)
    *               reduce using rule 44 (expression -> const .)
    /               reduce using rule 44 (expression -> const .)
    %               reduce using rule 44 (expression -> const .)
    |               reduce using rule 44 (expression -> const .)
    &               reduce using rule 44 (expression -> const .)
    ^               reduce using rule 44 (expression -> const .)
    AND             reduce using rule 44 (expression -> const .)
    OR              reduce using rule 44 (expression -> const .)
    SHL             reduce using rule 44 (expression -> const .)
    SHR             reduce using rule 44 (expression -> const .)
    EQ              reduce using rule 44 (expression -> const .)
    NEQ             reduce using rule 44 (expression -> const .)
    >               reduce using rule 44 (expression -> const .)
    <               reduce using rule 44 (expression -> const .)
    LE              reduce using rule 44 (expression -> const .)
    GE              reduce using rule 44 (expression -> const .)
    ;               reduce using rule 44 (expression -> const .)
    )               reduce using rule 44 (expression -> const .)
    ,               reduce using rule 44 (expression -> const .)


state 9

    (63) expression -> ( . expression )
    (64) expression -> ( . error )
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    error           shift and go to state 39
    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 40

state 10

    (21) instruction -> continue_instr .

    TYPE            reduce using rule 21 (instruction -> continue_instr .)
    error           reduce using rule 21 (instruction -> continue_instr .)
    PRINT           reduce using rule 21 (instruction -> continue_instr .)
    ID              reduce using rule 21 (instruction -> continue_instr .)
    IF              reduce using rule 21 (instruction -> continue_instr .)
    WHILE           reduce using rule 21 (instruction -> continue_instr .)
    REPEAT          reduce using rule 21 (instruction -> continue_instr .)
    RETURN          reduce using rule 21 (instruction -> continue_instr .)
    BREAK           reduce using rule 21 (instruction -> continue_instr .)
    CONTINUE        reduce using rule 21 (instruction -> continue_instr .)
    {               reduce using rule 21 (instruction -> continue_instr .)
    (               reduce using rule 21 (instruction -> continue_instr .)
    INTEGER         reduce using rule 21 (instruction -> continue_instr .)
    FLOAT           reduce using rule 21 (instruction -> continue_instr .)
    STRING          reduce using rule 21 (instruction -> continue_instr .)
    $end            reduce using rule 21 (instruction -> continue_instr .)
    UNTIL           reduce using rule 21 (instruction -> continue_instr .)
    }               reduce using rule 21 (instruction -> continue_instr .)
    ELSE            reduce using rule 21 (instruction -> continue_instr .)


state 11

    (17) instruction -> while_instr .

    TYPE            reduce using rule 17 (instruction -> while_instr .)
    error           reduce using rule 17 (instruction -> while_instr .)
    PRINT           reduce using rule 17 (instruction -> while_instr .)
    ID              reduce using rule 17 (instruction -> while_instr .)
    IF              reduce using rule 17 (instruction -> while_instr .)
    WHILE           reduce using rule 17 (instruction -> while_instr .)
    REPEAT          reduce using rule 17 (instruction -> while_instr .)
    RETURN          reduce using rule 17 (instruction -> while_instr .)
    BREAK           reduce using rule 17 (instruction -> while_instr .)
    CONTINUE        reduce using rule 17 (instruction -> while_instr .)
    {               reduce using rule 17 (instruction -> while_instr .)
    (               reduce using rule 17 (instruction -> while_instr .)
    INTEGER         reduce using rule 17 (instruction -> while_instr .)
    FLOAT           reduce using rule 17 (instruction -> while_instr .)
    STRING          reduce using rule 17 (instruction -> while_instr .)
    $end            reduce using rule 17 (instruction -> while_instr .)
    UNTIL           reduce using rule 17 (instruction -> while_instr .)
    }               reduce using rule 17 (instruction -> while_instr .)
    ELSE            reduce using rule 17 (instruction -> while_instr .)


state 12

    (0) S' -> program .



state 13

    (40) const -> INTEGER .

    +               reduce using rule 40 (const -> INTEGER .)
    -               reduce using rule 40 (const -> INTEGER .)
    *               reduce using rule 40 (const -> INTEGER .)
    /               reduce using rule 40 (const -> INTEGER .)
    %               reduce using rule 40 (const -> INTEGER .)
    |               reduce using rule 40 (const -> INTEGER .)
    &               reduce using rule 40 (const -> INTEGER .)
    ^               reduce using rule 40 (const -> INTEGER .)
    AND             reduce using rule 40 (const -> INTEGER .)
    OR              reduce using rule 40 (const -> INTEGER .)
    SHL             reduce using rule 40 (const -> INTEGER .)
    SHR             reduce using rule 40 (const -> INTEGER .)
    EQ              reduce using rule 40 (const -> INTEGER .)
    NEQ             reduce using rule 40 (const -> INTEGER .)
    >               reduce using rule 40 (const -> INTEGER .)
    <               reduce using rule 40 (const -> INTEGER .)
    LE              reduce using rule 40 (const -> INTEGER .)
    GE              reduce using rule 40 (const -> INTEGER .)
    )               reduce using rule 40 (const -> INTEGER .)
    ;               reduce using rule 40 (const -> INTEGER .)
    ,               reduce using rule 40 (const -> INTEGER .)


state 14

    (37) break_instr -> BREAK . ;

    ;               shift and go to state 41


state 15

    (34) repeat_instr -> REPEAT . anything_list UNTIL condition ;
    (3) anything_list -> . anything_list anything
    (4) anything_list -> . anything
    (5) anything -> . declaration
    (6) anything -> . fundef
    (7) anything -> . instruction
    (8) declaration -> . TYPE inits ;
    (9) declaration -> . error ;
    (71) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expression ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT anything_list UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { anything_list }
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    TYPE            shift and go to state 33
    error           shift and go to state 31
    PRINT           shift and go to state 4
    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 5
    REPEAT          shift and go to state 15
    RETURN          shift and go to state 2
    BREAK           shift and go to state 14
    CONTINUE        shift and go to state 29
    {               shift and go to state 32
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    choice_instr                   shift and go to state 3
    break_instr                    shift and go to state 24
    const                          shift and go to state 8
    anything                       shift and go to state 23
    return_instr                   shift and go to state 7
    assignment                     shift and go to state 17
    instruction                    shift and go to state 25
    compound_instr                 shift and go to state 19
    fundef                         shift and go to state 26
    labeled_instr                  shift and go to state 18
    anything_list                  shift and go to state 42
    print_instr                    shift and go to state 28
    repeat_instr                   shift and go to state 6
    declaration                    shift and go to state 20
    continue_instr                 shift and go to state 10
    while_instr                    shift and go to state 11
    expression                     shift and go to state 30

state 16

    (42) const -> STRING .

    +               reduce using rule 42 (const -> STRING .)
    -               reduce using rule 42 (const -> STRING .)
    *               reduce using rule 42 (const -> STRING .)
    /               reduce using rule 42 (const -> STRING .)
    %               reduce using rule 42 (const -> STRING .)
    |               reduce using rule 42 (const -> STRING .)
    &               reduce using rule 42 (const -> STRING .)
    ^               reduce using rule 42 (const -> STRING .)
    AND             reduce using rule 42 (const -> STRING .)
    OR              reduce using rule 42 (const -> STRING .)
    SHL             reduce using rule 42 (const -> STRING .)
    SHR             reduce using rule 42 (const -> STRING .)
    EQ              reduce using rule 42 (const -> STRING .)
    NEQ             reduce using rule 42 (const -> STRING .)
    >               reduce using rule 42 (const -> STRING .)
    <               reduce using rule 42 (const -> STRING .)
    LE              reduce using rule 42 (const -> STRING .)
    GE              reduce using rule 42 (const -> STRING .)
    )               reduce using rule 42 (const -> STRING .)
    ;               reduce using rule 42 (const -> STRING .)
    ,               reduce using rule 42 (const -> STRING .)


state 17

    (15) instruction -> assignment .

    TYPE            reduce using rule 15 (instruction -> assignment .)
    error           reduce using rule 15 (instruction -> assignment .)
    PRINT           reduce using rule 15 (instruction -> assignment .)
    ID              reduce using rule 15 (instruction -> assignment .)
    IF              reduce using rule 15 (instruction -> assignment .)
    WHILE           reduce using rule 15 (instruction -> assignment .)
    REPEAT          reduce using rule 15 (instruction -> assignment .)
    RETURN          reduce using rule 15 (instruction -> assignment .)
    BREAK           reduce using rule 15 (instruction -> assignment .)
    CONTINUE        reduce using rule 15 (instruction -> assignment .)
    {               reduce using rule 15 (instruction -> assignment .)
    (               reduce using rule 15 (instruction -> assignment .)
    INTEGER         reduce using rule 15 (instruction -> assignment .)
    FLOAT           reduce using rule 15 (instruction -> assignment .)
    STRING          reduce using rule 15 (instruction -> assignment .)
    $end            reduce using rule 15 (instruction -> assignment .)
    UNTIL           reduce using rule 15 (instruction -> assignment .)
    }               reduce using rule 15 (instruction -> assignment .)
    ELSE            reduce using rule 15 (instruction -> assignment .)


state 18

    (14) instruction -> labeled_instr .

    TYPE            reduce using rule 14 (instruction -> labeled_instr .)
    error           reduce using rule 14 (instruction -> labeled_instr .)
    PRINT           reduce using rule 14 (instruction -> labeled_instr .)
    ID              reduce using rule 14 (instruction -> labeled_instr .)
    IF              reduce using rule 14 (instruction -> labeled_instr .)
    WHILE           reduce using rule 14 (instruction -> labeled_instr .)
    REPEAT          reduce using rule 14 (instruction -> labeled_instr .)
    RETURN          reduce using rule 14 (instruction -> labeled_instr .)
    BREAK           reduce using rule 14 (instruction -> labeled_instr .)
    CONTINUE        reduce using rule 14 (instruction -> labeled_instr .)
    {               reduce using rule 14 (instruction -> labeled_instr .)
    (               reduce using rule 14 (instruction -> labeled_instr .)
    INTEGER         reduce using rule 14 (instruction -> labeled_instr .)
    FLOAT           reduce using rule 14 (instruction -> labeled_instr .)
    STRING          reduce using rule 14 (instruction -> labeled_instr .)
    $end            reduce using rule 14 (instruction -> labeled_instr .)
    UNTIL           reduce using rule 14 (instruction -> labeled_instr .)
    }               reduce using rule 14 (instruction -> labeled_instr .)
    ELSE            reduce using rule 14 (instruction -> labeled_instr .)


state 19

    (22) instruction -> compound_instr .

    TYPE            reduce using rule 22 (instruction -> compound_instr .)
    error           reduce using rule 22 (instruction -> compound_instr .)
    PRINT           reduce using rule 22 (instruction -> compound_instr .)
    ID              reduce using rule 22 (instruction -> compound_instr .)
    IF              reduce using rule 22 (instruction -> compound_instr .)
    WHILE           reduce using rule 22 (instruction -> compound_instr .)
    REPEAT          reduce using rule 22 (instruction -> compound_instr .)
    RETURN          reduce using rule 22 (instruction -> compound_instr .)
    BREAK           reduce using rule 22 (instruction -> compound_instr .)
    CONTINUE        reduce using rule 22 (instruction -> compound_instr .)
    {               reduce using rule 22 (instruction -> compound_instr .)
    (               reduce using rule 22 (instruction -> compound_instr .)
    INTEGER         reduce using rule 22 (instruction -> compound_instr .)
    FLOAT           reduce using rule 22 (instruction -> compound_instr .)
    STRING          reduce using rule 22 (instruction -> compound_instr .)
    $end            reduce using rule 22 (instruction -> compound_instr .)
    UNTIL           reduce using rule 22 (instruction -> compound_instr .)
    }               reduce using rule 22 (instruction -> compound_instr .)
    ELSE            reduce using rule 22 (instruction -> compound_instr .)


state 20

    (5) anything -> declaration .

    UNTIL           reduce using rule 5 (anything -> declaration .)
    TYPE            reduce using rule 5 (anything -> declaration .)
    error           reduce using rule 5 (anything -> declaration .)
    PRINT           reduce using rule 5 (anything -> declaration .)
    ID              reduce using rule 5 (anything -> declaration .)
    IF              reduce using rule 5 (anything -> declaration .)
    WHILE           reduce using rule 5 (anything -> declaration .)
    REPEAT          reduce using rule 5 (anything -> declaration .)
    RETURN          reduce using rule 5 (anything -> declaration .)
    BREAK           reduce using rule 5 (anything -> declaration .)
    CONTINUE        reduce using rule 5 (anything -> declaration .)
    {               reduce using rule 5 (anything -> declaration .)
    (               reduce using rule 5 (anything -> declaration .)
    INTEGER         reduce using rule 5 (anything -> declaration .)
    FLOAT           reduce using rule 5 (anything -> declaration .)
    STRING          reduce using rule 5 (anything -> declaration .)
    }               reduce using rule 5 (anything -> declaration .)
    $end            reduce using rule 5 (anything -> declaration .)


state 21

    (26) labeled_instr -> ID . : instruction
    (27) assignment -> ID . = expression ;
    (43) expression -> ID .
    (65) expression -> ID . ( expr_list_or_empty )
    (66) expression -> ID . ( error )

    :               shift and go to state 44
    =               shift and go to state 45
    ;               reduce using rule 43 (expression -> ID .)
    +               reduce using rule 43 (expression -> ID .)
    -               reduce using rule 43 (expression -> ID .)
    *               reduce using rule 43 (expression -> ID .)
    /               reduce using rule 43 (expression -> ID .)
    %               reduce using rule 43 (expression -> ID .)
    |               reduce using rule 43 (expression -> ID .)
    &               reduce using rule 43 (expression -> ID .)
    ^               reduce using rule 43 (expression -> ID .)
    AND             reduce using rule 43 (expression -> ID .)
    OR              reduce using rule 43 (expression -> ID .)
    SHL             reduce using rule 43 (expression -> ID .)
    SHR             reduce using rule 43 (expression -> ID .)
    EQ              reduce using rule 43 (expression -> ID .)
    NEQ             reduce using rule 43 (expression -> ID .)
    >               reduce using rule 43 (expression -> ID .)
    <               reduce using rule 43 (expression -> ID .)
    LE              reduce using rule 43 (expression -> ID .)
    GE              reduce using rule 43 (expression -> ID .)
    (               shift and go to state 43


state 22

    (28) choice_instr -> IF . ( condition ) instruction
    (29) choice_instr -> IF . ( condition ) instruction ELSE instruction
    (30) choice_instr -> IF . ( error ) instruction
    (31) choice_instr -> IF . ( error ) instruction ELSE instruction

    (               shift and go to state 46


state 23

    (4) anything_list -> anything .

    }               reduce using rule 4 (anything_list -> anything .)
    TYPE            reduce using rule 4 (anything_list -> anything .)
    error           reduce using rule 4 (anything_list -> anything .)
    PRINT           reduce using rule 4 (anything_list -> anything .)
    ID              reduce using rule 4 (anything_list -> anything .)
    IF              reduce using rule 4 (anything_list -> anything .)
    WHILE           reduce using rule 4 (anything_list -> anything .)
    REPEAT          reduce using rule 4 (anything_list -> anything .)
    RETURN          reduce using rule 4 (anything_list -> anything .)
    BREAK           reduce using rule 4 (anything_list -> anything .)
    CONTINUE        reduce using rule 4 (anything_list -> anything .)
    {               reduce using rule 4 (anything_list -> anything .)
    (               reduce using rule 4 (anything_list -> anything .)
    INTEGER         reduce using rule 4 (anything_list -> anything .)
    FLOAT           reduce using rule 4 (anything_list -> anything .)
    STRING          reduce using rule 4 (anything_list -> anything .)
    UNTIL           reduce using rule 4 (anything_list -> anything .)
    $end            reduce using rule 4 (anything_list -> anything .)


state 24

    (20) instruction -> break_instr .

    TYPE            reduce using rule 20 (instruction -> break_instr .)
    error           reduce using rule 20 (instruction -> break_instr .)
    PRINT           reduce using rule 20 (instruction -> break_instr .)
    ID              reduce using rule 20 (instruction -> break_instr .)
    IF              reduce using rule 20 (instruction -> break_instr .)
    WHILE           reduce using rule 20 (instruction -> break_instr .)
    REPEAT          reduce using rule 20 (instruction -> break_instr .)
    RETURN          reduce using rule 20 (instruction -> break_instr .)
    BREAK           reduce using rule 20 (instruction -> break_instr .)
    CONTINUE        reduce using rule 20 (instruction -> break_instr .)
    {               reduce using rule 20 (instruction -> break_instr .)
    (               reduce using rule 20 (instruction -> break_instr .)
    INTEGER         reduce using rule 20 (instruction -> break_instr .)
    FLOAT           reduce using rule 20 (instruction -> break_instr .)
    STRING          reduce using rule 20 (instruction -> break_instr .)
    $end            reduce using rule 20 (instruction -> break_instr .)
    UNTIL           reduce using rule 20 (instruction -> break_instr .)
    }               reduce using rule 20 (instruction -> break_instr .)
    ELSE            reduce using rule 20 (instruction -> break_instr .)


state 25

    (7) anything -> instruction .

    UNTIL           reduce using rule 7 (anything -> instruction .)
    TYPE            reduce using rule 7 (anything -> instruction .)
    error           reduce using rule 7 (anything -> instruction .)
    PRINT           reduce using rule 7 (anything -> instruction .)
    ID              reduce using rule 7 (anything -> instruction .)
    IF              reduce using rule 7 (anything -> instruction .)
    WHILE           reduce using rule 7 (anything -> instruction .)
    REPEAT          reduce using rule 7 (anything -> instruction .)
    RETURN          reduce using rule 7 (anything -> instruction .)
    BREAK           reduce using rule 7 (anything -> instruction .)
    CONTINUE        reduce using rule 7 (anything -> instruction .)
    {               reduce using rule 7 (anything -> instruction .)
    (               reduce using rule 7 (anything -> instruction .)
    INTEGER         reduce using rule 7 (anything -> instruction .)
    FLOAT           reduce using rule 7 (anything -> instruction .)
    STRING          reduce using rule 7 (anything -> instruction .)
    }               reduce using rule 7 (anything -> instruction .)
    $end            reduce using rule 7 (anything -> instruction .)


state 26

    (6) anything -> fundef .

    UNTIL           reduce using rule 6 (anything -> fundef .)
    TYPE            reduce using rule 6 (anything -> fundef .)
    error           reduce using rule 6 (anything -> fundef .)
    PRINT           reduce using rule 6 (anything -> fundef .)
    ID              reduce using rule 6 (anything -> fundef .)
    IF              reduce using rule 6 (anything -> fundef .)
    WHILE           reduce using rule 6 (anything -> fundef .)
    REPEAT          reduce using rule 6 (anything -> fundef .)
    RETURN          reduce using rule 6 (anything -> fundef .)
    BREAK           reduce using rule 6 (anything -> fundef .)
    CONTINUE        reduce using rule 6 (anything -> fundef .)
    {               reduce using rule 6 (anything -> fundef .)
    (               reduce using rule 6 (anything -> fundef .)
    INTEGER         reduce using rule 6 (anything -> fundef .)
    FLOAT           reduce using rule 6 (anything -> fundef .)
    STRING          reduce using rule 6 (anything -> fundef .)
    }               reduce using rule 6 (anything -> fundef .)
    $end            reduce using rule 6 (anything -> fundef .)


state 27

    (1) program -> anything_list .
    (3) anything_list -> anything_list . anything
    (5) anything -> . declaration
    (6) anything -> . fundef
    (7) anything -> . instruction
    (8) declaration -> . TYPE inits ;
    (9) declaration -> . error ;
    (71) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expression ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT anything_list UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { anything_list }
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    $end            reduce using rule 1 (program -> anything_list .)
    TYPE            shift and go to state 33
    error           shift and go to state 31
    PRINT           shift and go to state 4
    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 5
    REPEAT          shift and go to state 15
    RETURN          shift and go to state 2
    BREAK           shift and go to state 14
    CONTINUE        shift and go to state 29
    {               shift and go to state 32
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    choice_instr                   shift and go to state 3
    break_instr                    shift and go to state 24
    const                          shift and go to state 8
    anything                       shift and go to state 47
    return_instr                   shift and go to state 7
    assignment                     shift and go to state 17
    instruction                    shift and go to state 25
    compound_instr                 shift and go to state 19
    fundef                         shift and go to state 26
    labeled_instr                  shift and go to state 18
    print_instr                    shift and go to state 28
    continue_instr                 shift and go to state 10
    declaration                    shift and go to state 20
    while_instr                    shift and go to state 11
    expression                     shift and go to state 30
    repeat_instr                   shift and go to state 6

state 28

    (13) instruction -> print_instr .

    TYPE            reduce using rule 13 (instruction -> print_instr .)
    error           reduce using rule 13 (instruction -> print_instr .)
    PRINT           reduce using rule 13 (instruction -> print_instr .)
    ID              reduce using rule 13 (instruction -> print_instr .)
    IF              reduce using rule 13 (instruction -> print_instr .)
    WHILE           reduce using rule 13 (instruction -> print_instr .)
    REPEAT          reduce using rule 13 (instruction -> print_instr .)
    RETURN          reduce using rule 13 (instruction -> print_instr .)
    BREAK           reduce using rule 13 (instruction -> print_instr .)
    CONTINUE        reduce using rule 13 (instruction -> print_instr .)
    {               reduce using rule 13 (instruction -> print_instr .)
    (               reduce using rule 13 (instruction -> print_instr .)
    INTEGER         reduce using rule 13 (instruction -> print_instr .)
    FLOAT           reduce using rule 13 (instruction -> print_instr .)
    STRING          reduce using rule 13 (instruction -> print_instr .)
    $end            reduce using rule 13 (instruction -> print_instr .)
    UNTIL           reduce using rule 13 (instruction -> print_instr .)
    }               reduce using rule 13 (instruction -> print_instr .)
    ELSE            reduce using rule 13 (instruction -> print_instr .)


state 29

    (36) continue_instr -> CONTINUE . ;

    ;               shift and go to state 48


state 30

    (23) instruction -> expression . ;
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    ;               shift and go to state 64
    +               shift and go to state 56
    -               shift and go to state 58
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52
    |               shift and go to state 66
    &               shift and go to state 53
    ^               shift and go to state 67
    AND             shift and go to state 49
    OR              shift and go to state 60
    SHL             shift and go to state 55
    SHR             shift and go to state 50
    EQ              shift and go to state 61
    NEQ             shift and go to state 65
    >               shift and go to state 62
    <               shift and go to state 54
    LE              shift and go to state 51
    GE              shift and go to state 63


state 31

    (9) declaration -> error . ;

    ;               shift and go to state 68


state 32

    (38) compound_instr -> { . anything_list }
    (3) anything_list -> . anything_list anything
    (4) anything_list -> . anything
    (5) anything -> . declaration
    (6) anything -> . fundef
    (7) anything -> . instruction
    (8) declaration -> . TYPE inits ;
    (9) declaration -> . error ;
    (71) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expression ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT anything_list UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { anything_list }
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    TYPE            shift and go to state 33
    error           shift and go to state 31
    PRINT           shift and go to state 4
    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 5
    REPEAT          shift and go to state 15
    RETURN          shift and go to state 2
    BREAK           shift and go to state 14
    CONTINUE        shift and go to state 29
    {               shift and go to state 32
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    choice_instr                   shift and go to state 3
    break_instr                    shift and go to state 24
    const                          shift and go to state 8
    anything                       shift and go to state 23
    return_instr                   shift and go to state 7
    assignment                     shift and go to state 17
    instruction                    shift and go to state 25
    compound_instr                 shift and go to state 19
    fundef                         shift and go to state 26
    labeled_instr                  shift and go to state 18
    anything_list                  shift and go to state 69
    print_instr                    shift and go to state 28
    continue_instr                 shift and go to state 10
    declaration                    shift and go to state 20
    while_instr                    shift and go to state 11
    expression                     shift and go to state 30
    repeat_instr                   shift and go to state 6

state 33

    (8) declaration -> TYPE . inits ;
    (71) fundef -> TYPE . ID ( args_list_or_empty ) compound_instr
    (10) inits -> . inits , init
    (11) inits -> . init
    (12) init -> . ID = expression

    ID              shift and go to state 72

    init                           shift and go to state 70
    inits                          shift and go to state 71

state 34

    (43) expression -> ID .
    (65) expression -> ID . ( expr_list_or_empty )
    (66) expression -> ID . ( error )

    +               reduce using rule 43 (expression -> ID .)
    -               reduce using rule 43 (expression -> ID .)
    *               reduce using rule 43 (expression -> ID .)
    /               reduce using rule 43 (expression -> ID .)
    %               reduce using rule 43 (expression -> ID .)
    |               reduce using rule 43 (expression -> ID .)
    &               reduce using rule 43 (expression -> ID .)
    ^               reduce using rule 43 (expression -> ID .)
    AND             reduce using rule 43 (expression -> ID .)
    OR              reduce using rule 43 (expression -> ID .)
    SHL             reduce using rule 43 (expression -> ID .)
    SHR             reduce using rule 43 (expression -> ID .)
    EQ              reduce using rule 43 (expression -> ID .)
    NEQ             reduce using rule 43 (expression -> ID .)
    >               reduce using rule 43 (expression -> ID .)
    <               reduce using rule 43 (expression -> ID .)
    LE              reduce using rule 43 (expression -> ID .)
    GE              reduce using rule 43 (expression -> ID .)
    ;               reduce using rule 43 (expression -> ID .)
    )               reduce using rule 43 (expression -> ID .)
    ,               reduce using rule 43 (expression -> ID .)
    (               shift and go to state 43


state 35

    (35) return_instr -> RETURN expression . ;
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    ;               shift and go to state 73
    +               shift and go to state 56
    -               shift and go to state 58
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52
    |               shift and go to state 66
    &               shift and go to state 53
    ^               shift and go to state 67
    AND             shift and go to state 49
    OR              shift and go to state 60
    SHL             shift and go to state 55
    SHR             shift and go to state 50
    EQ              shift and go to state 61
    NEQ             shift and go to state 65
    >               shift and go to state 62
    <               shift and go to state 54
    LE              shift and go to state 51
    GE              shift and go to state 63


state 36

    (25) print_instr -> PRINT error . ;

    ;               shift and go to state 74


state 37

    (24) print_instr -> PRINT expression . ;
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    ;               shift and go to state 75
    +               shift and go to state 56
    -               shift and go to state 58
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52
    |               shift and go to state 66
    &               shift and go to state 53
    ^               shift and go to state 67
    AND             shift and go to state 49
    OR              shift and go to state 60
    SHL             shift and go to state 55
    SHR             shift and go to state 50
    EQ              shift and go to state 61
    NEQ             shift and go to state 65
    >               shift and go to state 62
    <               shift and go to state 54
    LE              shift and go to state 51
    GE              shift and go to state 63


state 38

    (32) while_instr -> WHILE ( . condition ) instruction
    (33) while_instr -> WHILE ( . error ) instruction
    (39) condition -> . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    error           shift and go to state 77
    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 78
    condition                      shift and go to state 76

state 39

    (64) expression -> ( error . )

    )               shift and go to state 79


state 40

    (63) expression -> ( expression . )
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    )               shift and go to state 80
    +               shift and go to state 56
    -               shift and go to state 58
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52
    |               shift and go to state 66
    &               shift and go to state 53
    ^               shift and go to state 67
    AND             shift and go to state 49
    OR              shift and go to state 60
    SHL             shift and go to state 55
    SHR             shift and go to state 50
    EQ              shift and go to state 61
    NEQ             shift and go to state 65
    >               shift and go to state 62
    <               shift and go to state 54
    LE              shift and go to state 51
    GE              shift and go to state 63


state 41

    (37) break_instr -> BREAK ; .

    TYPE            reduce using rule 37 (break_instr -> BREAK ; .)
    error           reduce using rule 37 (break_instr -> BREAK ; .)
    PRINT           reduce using rule 37 (break_instr -> BREAK ; .)
    ID              reduce using rule 37 (break_instr -> BREAK ; .)
    IF              reduce using rule 37 (break_instr -> BREAK ; .)
    WHILE           reduce using rule 37 (break_instr -> BREAK ; .)
    REPEAT          reduce using rule 37 (break_instr -> BREAK ; .)
    RETURN          reduce using rule 37 (break_instr -> BREAK ; .)
    BREAK           reduce using rule 37 (break_instr -> BREAK ; .)
    CONTINUE        reduce using rule 37 (break_instr -> BREAK ; .)
    {               reduce using rule 37 (break_instr -> BREAK ; .)
    (               reduce using rule 37 (break_instr -> BREAK ; .)
    INTEGER         reduce using rule 37 (break_instr -> BREAK ; .)
    FLOAT           reduce using rule 37 (break_instr -> BREAK ; .)
    STRING          reduce using rule 37 (break_instr -> BREAK ; .)
    $end            reduce using rule 37 (break_instr -> BREAK ; .)
    UNTIL           reduce using rule 37 (break_instr -> BREAK ; .)
    }               reduce using rule 37 (break_instr -> BREAK ; .)
    ELSE            reduce using rule 37 (break_instr -> BREAK ; .)


state 42

    (34) repeat_instr -> REPEAT anything_list . UNTIL condition ;
    (3) anything_list -> anything_list . anything
    (5) anything -> . declaration
    (6) anything -> . fundef
    (7) anything -> . instruction
    (8) declaration -> . TYPE inits ;
    (9) declaration -> . error ;
    (71) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expression ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT anything_list UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { anything_list }
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    UNTIL           shift and go to state 81
    TYPE            shift and go to state 33
    error           shift and go to state 31
    PRINT           shift and go to state 4
    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 5
    REPEAT          shift and go to state 15
    RETURN          shift and go to state 2
    BREAK           shift and go to state 14
    CONTINUE        shift and go to state 29
    {               shift and go to state 32
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    choice_instr                   shift and go to state 3
    break_instr                    shift and go to state 24
    const                          shift and go to state 8
    anything                       shift and go to state 47
    return_instr                   shift and go to state 7
    assignment                     shift and go to state 17
    instruction                    shift and go to state 25
    compound_instr                 shift and go to state 19
    fundef                         shift and go to state 26
    labeled_instr                  shift and go to state 18
    print_instr                    shift and go to state 28
    repeat_instr                   shift and go to state 6
    declaration                    shift and go to state 20
    continue_instr                 shift and go to state 10
    while_instr                    shift and go to state 11
    expression                     shift and go to state 30

state 43

    (65) expression -> ID ( . expr_list_or_empty )
    (66) expression -> ID ( . error )
    (67) expr_list_or_empty -> . expr_list
    (68) expr_list_or_empty -> .
    (69) expr_list -> . expr_list , expression
    (70) expr_list -> . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    error           shift and go to state 84
    )               reduce using rule 68 (expr_list_or_empty -> .)
    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    expr_list                      shift and go to state 82
    expr_list_or_empty             shift and go to state 83
    expression                     shift and go to state 85
    const                          shift and go to state 8

state 44

    (26) labeled_instr -> ID : . instruction
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expression ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT anything_list UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { anything_list }
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    PRINT           shift and go to state 4
    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 5
    REPEAT          shift and go to state 15
    RETURN          shift and go to state 2
    BREAK           shift and go to state 14
    CONTINUE        shift and go to state 29
    {               shift and go to state 32
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    return_instr                   shift and go to state 7
    const                          shift and go to state 8
    assignment                     shift and go to state 17
    instruction                    shift and go to state 86
    compound_instr                 shift and go to state 19
    continue_instr                 shift and go to state 10
    while_instr                    shift and go to state 11
    print_instr                    shift and go to state 28
    choice_instr                   shift and go to state 3
    break_instr                    shift and go to state 24
    labeled_instr                  shift and go to state 18
    expression                     shift and go to state 30
    repeat_instr                   shift and go to state 6

state 45

    (27) assignment -> ID = . expression ;
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 87

state 46

    (28) choice_instr -> IF ( . condition ) instruction
    (29) choice_instr -> IF ( . condition ) instruction ELSE instruction
    (30) choice_instr -> IF ( . error ) instruction
    (31) choice_instr -> IF ( . error ) instruction ELSE instruction
    (39) condition -> . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    error           shift and go to state 89
    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 78
    condition                      shift and go to state 88

state 47

    (3) anything_list -> anything_list anything .

    }               reduce using rule 3 (anything_list -> anything_list anything .)
    TYPE            reduce using rule 3 (anything_list -> anything_list anything .)
    error           reduce using rule 3 (anything_list -> anything_list anything .)
    PRINT           reduce using rule 3 (anything_list -> anything_list anything .)
    ID              reduce using rule 3 (anything_list -> anything_list anything .)
    IF              reduce using rule 3 (anything_list -> anything_list anything .)
    WHILE           reduce using rule 3 (anything_list -> anything_list anything .)
    REPEAT          reduce using rule 3 (anything_list -> anything_list anything .)
    RETURN          reduce using rule 3 (anything_list -> anything_list anything .)
    BREAK           reduce using rule 3 (anything_list -> anything_list anything .)
    CONTINUE        reduce using rule 3 (anything_list -> anything_list anything .)
    {               reduce using rule 3 (anything_list -> anything_list anything .)
    (               reduce using rule 3 (anything_list -> anything_list anything .)
    INTEGER         reduce using rule 3 (anything_list -> anything_list anything .)
    FLOAT           reduce using rule 3 (anything_list -> anything_list anything .)
    STRING          reduce using rule 3 (anything_list -> anything_list anything .)
    UNTIL           reduce using rule 3 (anything_list -> anything_list anything .)
    $end            reduce using rule 3 (anything_list -> anything_list anything .)


state 48

    (36) continue_instr -> CONTINUE ; .

    UNTIL           reduce using rule 36 (continue_instr -> CONTINUE ; .)
    TYPE            reduce using rule 36 (continue_instr -> CONTINUE ; .)
    error           reduce using rule 36 (continue_instr -> CONTINUE ; .)
    PRINT           reduce using rule 36 (continue_instr -> CONTINUE ; .)
    ID              reduce using rule 36 (continue_instr -> CONTINUE ; .)
    IF              reduce using rule 36 (continue_instr -> CONTINUE ; .)
    WHILE           reduce using rule 36 (continue_instr -> CONTINUE ; .)
    REPEAT          reduce using rule 36 (continue_instr -> CONTINUE ; .)
    RETURN          reduce using rule 36 (continue_instr -> CONTINUE ; .)
    BREAK           reduce using rule 36 (continue_instr -> CONTINUE ; .)
    CONTINUE        reduce using rule 36 (continue_instr -> CONTINUE ; .)
    {               reduce using rule 36 (continue_instr -> CONTINUE ; .)
    (               reduce using rule 36 (continue_instr -> CONTINUE ; .)
    INTEGER         reduce using rule 36 (continue_instr -> CONTINUE ; .)
    FLOAT           reduce using rule 36 (continue_instr -> CONTINUE ; .)
    STRING          reduce using rule 36 (continue_instr -> CONTINUE ; .)
    $end            reduce using rule 36 (continue_instr -> CONTINUE ; .)
    }               reduce using rule 36 (continue_instr -> CONTINUE ; .)
    ELSE            reduce using rule 36 (continue_instr -> CONTINUE ; .)


state 49

    (53) expression -> expression AND . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 90

state 50

    (56) expression -> expression SHR . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 91

state 51

    (61) expression -> expression LE . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 92

state 52

    (49) expression -> expression % . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 93

state 53

    (51) expression -> expression & . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 94

state 54

    (60) expression -> expression < . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 95

state 55

    (55) expression -> expression SHL . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 96

state 56

    (45) expression -> expression + . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 97

state 57

    (47) expression -> expression * . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 98

state 58

    (46) expression -> expression - . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 99

state 59

    (48) expression -> expression / . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 100

state 60

    (54) expression -> expression OR . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 101

state 61

    (57) expression -> expression EQ . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 102

state 62

    (59) expression -> expression > . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 103

state 63

    (62) expression -> expression GE . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 104

state 64

    (23) instruction -> expression ; .

    TYPE            reduce using rule 23 (instruction -> expression ; .)
    error           reduce using rule 23 (instruction -> expression ; .)
    PRINT           reduce using rule 23 (instruction -> expression ; .)
    ID              reduce using rule 23 (instruction -> expression ; .)
    IF              reduce using rule 23 (instruction -> expression ; .)
    WHILE           reduce using rule 23 (instruction -> expression ; .)
    REPEAT          reduce using rule 23 (instruction -> expression ; .)
    RETURN          reduce using rule 23 (instruction -> expression ; .)
    BREAK           reduce using rule 23 (instruction -> expression ; .)
    CONTINUE        reduce using rule 23 (instruction -> expression ; .)
    {               reduce using rule 23 (instruction -> expression ; .)
    (               reduce using rule 23 (instruction -> expression ; .)
    INTEGER         reduce using rule 23 (instruction -> expression ; .)
    FLOAT           reduce using rule 23 (instruction -> expression ; .)
    STRING          reduce using rule 23 (instruction -> expression ; .)
    $end            reduce using rule 23 (instruction -> expression ; .)
    UNTIL           reduce using rule 23 (instruction -> expression ; .)
    }               reduce using rule 23 (instruction -> expression ; .)
    ELSE            reduce using rule 23 (instruction -> expression ; .)


state 65

    (58) expression -> expression NEQ . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 105

state 66

    (50) expression -> expression | . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 106

state 67

    (52) expression -> expression ^ . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 107

state 68

    (9) declaration -> error ; .

    UNTIL           reduce using rule 9 (declaration -> error ; .)
    TYPE            reduce using rule 9 (declaration -> error ; .)
    error           reduce using rule 9 (declaration -> error ; .)
    PRINT           reduce using rule 9 (declaration -> error ; .)
    ID              reduce using rule 9 (declaration -> error ; .)
    IF              reduce using rule 9 (declaration -> error ; .)
    WHILE           reduce using rule 9 (declaration -> error ; .)
    REPEAT          reduce using rule 9 (declaration -> error ; .)
    RETURN          reduce using rule 9 (declaration -> error ; .)
    BREAK           reduce using rule 9 (declaration -> error ; .)
    CONTINUE        reduce using rule 9 (declaration -> error ; .)
    {               reduce using rule 9 (declaration -> error ; .)
    (               reduce using rule 9 (declaration -> error ; .)
    INTEGER         reduce using rule 9 (declaration -> error ; .)
    FLOAT           reduce using rule 9 (declaration -> error ; .)
    STRING          reduce using rule 9 (declaration -> error ; .)
    }               reduce using rule 9 (declaration -> error ; .)
    $end            reduce using rule 9 (declaration -> error ; .)


state 69

    (38) compound_instr -> { anything_list . }
    (3) anything_list -> anything_list . anything
    (5) anything -> . declaration
    (6) anything -> . fundef
    (7) anything -> . instruction
    (8) declaration -> . TYPE inits ;
    (9) declaration -> . error ;
    (71) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expression ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT anything_list UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { anything_list }
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    }               shift and go to state 108
    TYPE            shift and go to state 33
    error           shift and go to state 31
    PRINT           shift and go to state 4
    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 5
    REPEAT          shift and go to state 15
    RETURN          shift and go to state 2
    BREAK           shift and go to state 14
    CONTINUE        shift and go to state 29
    {               shift and go to state 32
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    choice_instr                   shift and go to state 3
    break_instr                    shift and go to state 24
    const                          shift and go to state 8
    anything                       shift and go to state 47
    return_instr                   shift and go to state 7
    assignment                     shift and go to state 17
    instruction                    shift and go to state 25
    compound_instr                 shift and go to state 19
    fundef                         shift and go to state 26
    labeled_instr                  shift and go to state 18
    print_instr                    shift and go to state 28
    continue_instr                 shift and go to state 10
    declaration                    shift and go to state 20
    while_instr                    shift and go to state 11
    expression                     shift and go to state 30
    repeat_instr                   shift and go to state 6

state 70

    (11) inits -> init .

    ;               reduce using rule 11 (inits -> init .)
    ,               reduce using rule 11 (inits -> init .)


state 71

    (8) declaration -> TYPE inits . ;
    (10) inits -> inits . , init

    ;               shift and go to state 109
    ,               shift and go to state 110


state 72

    (71) fundef -> TYPE ID . ( args_list_or_empty ) compound_instr
    (12) init -> ID . = expression

    (               shift and go to state 111
    =               shift and go to state 112


state 73

    (35) return_instr -> RETURN expression ; .

    }               reduce using rule 35 (return_instr -> RETURN expression ; .)
    TYPE            reduce using rule 35 (return_instr -> RETURN expression ; .)
    error           reduce using rule 35 (return_instr -> RETURN expression ; .)
    PRINT           reduce using rule 35 (return_instr -> RETURN expression ; .)
    ID              reduce using rule 35 (return_instr -> RETURN expression ; .)
    IF              reduce using rule 35 (return_instr -> RETURN expression ; .)
    WHILE           reduce using rule 35 (return_instr -> RETURN expression ; .)
    REPEAT          reduce using rule 35 (return_instr -> RETURN expression ; .)
    RETURN          reduce using rule 35 (return_instr -> RETURN expression ; .)
    BREAK           reduce using rule 35 (return_instr -> RETURN expression ; .)
    CONTINUE        reduce using rule 35 (return_instr -> RETURN expression ; .)
    {               reduce using rule 35 (return_instr -> RETURN expression ; .)
    (               reduce using rule 35 (return_instr -> RETURN expression ; .)
    INTEGER         reduce using rule 35 (return_instr -> RETURN expression ; .)
    FLOAT           reduce using rule 35 (return_instr -> RETURN expression ; .)
    STRING          reduce using rule 35 (return_instr -> RETURN expression ; .)
    $end            reduce using rule 35 (return_instr -> RETURN expression ; .)
    UNTIL           reduce using rule 35 (return_instr -> RETURN expression ; .)
    ELSE            reduce using rule 35 (return_instr -> RETURN expression ; .)


state 74

    (25) print_instr -> PRINT error ; .

    TYPE            reduce using rule 25 (print_instr -> PRINT error ; .)
    error           reduce using rule 25 (print_instr -> PRINT error ; .)
    PRINT           reduce using rule 25 (print_instr -> PRINT error ; .)
    ID              reduce using rule 25 (print_instr -> PRINT error ; .)
    IF              reduce using rule 25 (print_instr -> PRINT error ; .)
    WHILE           reduce using rule 25 (print_instr -> PRINT error ; .)
    REPEAT          reduce using rule 25 (print_instr -> PRINT error ; .)
    RETURN          reduce using rule 25 (print_instr -> PRINT error ; .)
    BREAK           reduce using rule 25 (print_instr -> PRINT error ; .)
    CONTINUE        reduce using rule 25 (print_instr -> PRINT error ; .)
    {               reduce using rule 25 (print_instr -> PRINT error ; .)
    (               reduce using rule 25 (print_instr -> PRINT error ; .)
    INTEGER         reduce using rule 25 (print_instr -> PRINT error ; .)
    FLOAT           reduce using rule 25 (print_instr -> PRINT error ; .)
    STRING          reduce using rule 25 (print_instr -> PRINT error ; .)
    $end            reduce using rule 25 (print_instr -> PRINT error ; .)
    UNTIL           reduce using rule 25 (print_instr -> PRINT error ; .)
    }               reduce using rule 25 (print_instr -> PRINT error ; .)
    ELSE            reduce using rule 25 (print_instr -> PRINT error ; .)


state 75

    (24) print_instr -> PRINT expression ; .

    TYPE            reduce using rule 24 (print_instr -> PRINT expression ; .)
    error           reduce using rule 24 (print_instr -> PRINT expression ; .)
    PRINT           reduce using rule 24 (print_instr -> PRINT expression ; .)
    ID              reduce using rule 24 (print_instr -> PRINT expression ; .)
    IF              reduce using rule 24 (print_instr -> PRINT expression ; .)
    WHILE           reduce using rule 24 (print_instr -> PRINT expression ; .)
    REPEAT          reduce using rule 24 (print_instr -> PRINT expression ; .)
    RETURN          reduce using rule 24 (print_instr -> PRINT expression ; .)
    BREAK           reduce using rule 24 (print_instr -> PRINT expression ; .)
    CONTINUE        reduce using rule 24 (print_instr -> PRINT expression ; .)
    {               reduce using rule 24 (print_instr -> PRINT expression ; .)
    (               reduce using rule 24 (print_instr -> PRINT expression ; .)
    INTEGER         reduce using rule 24 (print_instr -> PRINT expression ; .)
    FLOAT           reduce using rule 24 (print_instr -> PRINT expression ; .)
    STRING          reduce using rule 24 (print_instr -> PRINT expression ; .)
    $end            reduce using rule 24 (print_instr -> PRINT expression ; .)
    UNTIL           reduce using rule 24 (print_instr -> PRINT expression ; .)
    }               reduce using rule 24 (print_instr -> PRINT expression ; .)
    ELSE            reduce using rule 24 (print_instr -> PRINT expression ; .)


state 76

    (32) while_instr -> WHILE ( condition . ) instruction

    )               shift and go to state 113


state 77

    (33) while_instr -> WHILE ( error . ) instruction

    )               shift and go to state 114


state 78

    (39) condition -> expression .
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    )               reduce using rule 39 (condition -> expression .)
    ;               reduce using rule 39 (condition -> expression .)
    +               shift and go to state 56
    -               shift and go to state 58
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52
    |               shift and go to state 66
    &               shift and go to state 53
    ^               shift and go to state 67
    AND             shift and go to state 49
    OR              shift and go to state 60
    SHL             shift and go to state 55
    SHR             shift and go to state 50
    EQ              shift and go to state 61
    NEQ             shift and go to state 65
    >               shift and go to state 62
    <               shift and go to state 54
    LE              shift and go to state 51
    GE              shift and go to state 63


state 79

    (64) expression -> ( error ) .

    +               reduce using rule 64 (expression -> ( error ) .)
    -               reduce using rule 64 (expression -> ( error ) .)
    *               reduce using rule 64 (expression -> ( error ) .)
    /               reduce using rule 64 (expression -> ( error ) .)
    %               reduce using rule 64 (expression -> ( error ) .)
    |               reduce using rule 64 (expression -> ( error ) .)
    &               reduce using rule 64 (expression -> ( error ) .)
    ^               reduce using rule 64 (expression -> ( error ) .)
    AND             reduce using rule 64 (expression -> ( error ) .)
    OR              reduce using rule 64 (expression -> ( error ) .)
    SHL             reduce using rule 64 (expression -> ( error ) .)
    SHR             reduce using rule 64 (expression -> ( error ) .)
    EQ              reduce using rule 64 (expression -> ( error ) .)
    NEQ             reduce using rule 64 (expression -> ( error ) .)
    >               reduce using rule 64 (expression -> ( error ) .)
    <               reduce using rule 64 (expression -> ( error ) .)
    LE              reduce using rule 64 (expression -> ( error ) .)
    GE              reduce using rule 64 (expression -> ( error ) .)
    ;               reduce using rule 64 (expression -> ( error ) .)
    )               reduce using rule 64 (expression -> ( error ) .)
    ,               reduce using rule 64 (expression -> ( error ) .)


state 80

    (63) expression -> ( expression ) .

    +               reduce using rule 63 (expression -> ( expression ) .)
    -               reduce using rule 63 (expression -> ( expression ) .)
    *               reduce using rule 63 (expression -> ( expression ) .)
    /               reduce using rule 63 (expression -> ( expression ) .)
    %               reduce using rule 63 (expression -> ( expression ) .)
    |               reduce using rule 63 (expression -> ( expression ) .)
    &               reduce using rule 63 (expression -> ( expression ) .)
    ^               reduce using rule 63 (expression -> ( expression ) .)
    AND             reduce using rule 63 (expression -> ( expression ) .)
    OR              reduce using rule 63 (expression -> ( expression ) .)
    SHL             reduce using rule 63 (expression -> ( expression ) .)
    SHR             reduce using rule 63 (expression -> ( expression ) .)
    EQ              reduce using rule 63 (expression -> ( expression ) .)
    NEQ             reduce using rule 63 (expression -> ( expression ) .)
    >               reduce using rule 63 (expression -> ( expression ) .)
    <               reduce using rule 63 (expression -> ( expression ) .)
    LE              reduce using rule 63 (expression -> ( expression ) .)
    GE              reduce using rule 63 (expression -> ( expression ) .)
    ;               reduce using rule 63 (expression -> ( expression ) .)
    )               reduce using rule 63 (expression -> ( expression ) .)
    ,               reduce using rule 63 (expression -> ( expression ) .)


state 81

    (34) repeat_instr -> REPEAT anything_list UNTIL . condition ;
    (39) condition -> . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 78
    condition                      shift and go to state 115

state 82

    (67) expr_list_or_empty -> expr_list .
    (69) expr_list -> expr_list . , expression

    )               reduce using rule 67 (expr_list_or_empty -> expr_list .)
    ,               shift and go to state 116


state 83

    (65) expression -> ID ( expr_list_or_empty . )

    )               shift and go to state 117


state 84

    (66) expression -> ID ( error . )

    )               shift and go to state 118


state 85

    (70) expr_list -> expression .
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    ,               reduce using rule 70 (expr_list -> expression .)
    )               reduce using rule 70 (expr_list -> expression .)
    +               shift and go to state 56
    -               shift and go to state 58
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52
    |               shift and go to state 66
    &               shift and go to state 53
    ^               shift and go to state 67
    AND             shift and go to state 49
    OR              shift and go to state 60
    SHL             shift and go to state 55
    SHR             shift and go to state 50
    EQ              shift and go to state 61
    NEQ             shift and go to state 65
    >               shift and go to state 62
    <               shift and go to state 54
    LE              shift and go to state 51
    GE              shift and go to state 63


state 86

    (26) labeled_instr -> ID : instruction .

    TYPE            reduce using rule 26 (labeled_instr -> ID : instruction .)
    error           reduce using rule 26 (labeled_instr -> ID : instruction .)
    PRINT           reduce using rule 26 (labeled_instr -> ID : instruction .)
    ID              reduce using rule 26 (labeled_instr -> ID : instruction .)
    IF              reduce using rule 26 (labeled_instr -> ID : instruction .)
    WHILE           reduce using rule 26 (labeled_instr -> ID : instruction .)
    REPEAT          reduce using rule 26 (labeled_instr -> ID : instruction .)
    RETURN          reduce using rule 26 (labeled_instr -> ID : instruction .)
    BREAK           reduce using rule 26 (labeled_instr -> ID : instruction .)
    CONTINUE        reduce using rule 26 (labeled_instr -> ID : instruction .)
    {               reduce using rule 26 (labeled_instr -> ID : instruction .)
    (               reduce using rule 26 (labeled_instr -> ID : instruction .)
    INTEGER         reduce using rule 26 (labeled_instr -> ID : instruction .)
    FLOAT           reduce using rule 26 (labeled_instr -> ID : instruction .)
    STRING          reduce using rule 26 (labeled_instr -> ID : instruction .)
    $end            reduce using rule 26 (labeled_instr -> ID : instruction .)
    UNTIL           reduce using rule 26 (labeled_instr -> ID : instruction .)
    }               reduce using rule 26 (labeled_instr -> ID : instruction .)
    ELSE            reduce using rule 26 (labeled_instr -> ID : instruction .)


state 87

    (27) assignment -> ID = expression . ;
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    ;               shift and go to state 119
    +               shift and go to state 56
    -               shift and go to state 58
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52
    |               shift and go to state 66
    &               shift and go to state 53
    ^               shift and go to state 67
    AND             shift and go to state 49
    OR              shift and go to state 60
    SHL             shift and go to state 55
    SHR             shift and go to state 50
    EQ              shift and go to state 61
    NEQ             shift and go to state 65
    >               shift and go to state 62
    <               shift and go to state 54
    LE              shift and go to state 51
    GE              shift and go to state 63


state 88

    (28) choice_instr -> IF ( condition . ) instruction
    (29) choice_instr -> IF ( condition . ) instruction ELSE instruction

    )               shift and go to state 120


state 89

    (30) choice_instr -> IF ( error . ) instruction
    (31) choice_instr -> IF ( error . ) instruction ELSE instruction

    )               shift and go to state 121


state 90

    (53) expression -> expression AND expression .
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    AND             reduce using rule 53 (expression -> expression AND expression .)
    OR              reduce using rule 53 (expression -> expression AND expression .)
    ;               reduce using rule 53 (expression -> expression AND expression .)
    )               reduce using rule 53 (expression -> expression AND expression .)
    ,               reduce using rule 53 (expression -> expression AND expression .)
    +               shift and go to state 56
    -               shift and go to state 58
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52
    |               shift and go to state 66
    &               shift and go to state 53
    ^               shift and go to state 67
    SHL             shift and go to state 55
    SHR             shift and go to state 50
    EQ              shift and go to state 61
    NEQ             shift and go to state 65
    >               shift and go to state 62
    <               shift and go to state 54
    LE              shift and go to state 51
    GE              shift and go to state 63

  ! +               [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! -               [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! *               [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! /               [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! %               [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! |               [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! &               [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! ^               [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! SHL             [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! SHR             [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! EQ              [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! NEQ             [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! >               [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! <               [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! LE              [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! GE              [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 60 ]


state 91

    (56) expression -> expression SHR expression .
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    |               reduce using rule 56 (expression -> expression SHR expression .)
    &               reduce using rule 56 (expression -> expression SHR expression .)
    ^               reduce using rule 56 (expression -> expression SHR expression .)
    AND             reduce using rule 56 (expression -> expression SHR expression .)
    OR              reduce using rule 56 (expression -> expression SHR expression .)
    SHL             reduce using rule 56 (expression -> expression SHR expression .)
    SHR             reduce using rule 56 (expression -> expression SHR expression .)
    EQ              reduce using rule 56 (expression -> expression SHR expression .)
    NEQ             reduce using rule 56 (expression -> expression SHR expression .)
    >               reduce using rule 56 (expression -> expression SHR expression .)
    <               reduce using rule 56 (expression -> expression SHR expression .)
    LE              reduce using rule 56 (expression -> expression SHR expression .)
    GE              reduce using rule 56 (expression -> expression SHR expression .)
    ;               reduce using rule 56 (expression -> expression SHR expression .)
    )               reduce using rule 56 (expression -> expression SHR expression .)
    ,               reduce using rule 56 (expression -> expression SHR expression .)
    +               shift and go to state 56
    -               shift and go to state 58
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52

  ! +               [ reduce using rule 56 (expression -> expression SHR expression .) ]
  ! -               [ reduce using rule 56 (expression -> expression SHR expression .) ]
  ! *               [ reduce using rule 56 (expression -> expression SHR expression .) ]
  ! /               [ reduce using rule 56 (expression -> expression SHR expression .) ]
  ! %               [ reduce using rule 56 (expression -> expression SHR expression .) ]
  ! |               [ shift and go to state 66 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 60 ]
  ! SHL             [ shift and go to state 55 ]
  ! SHR             [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 61 ]
  ! NEQ             [ shift and go to state 65 ]
  ! >               [ shift and go to state 62 ]
  ! <               [ shift and go to state 54 ]
  ! LE              [ shift and go to state 51 ]
  ! GE              [ shift and go to state 63 ]


state 92

    (61) expression -> expression LE expression .
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    |               reduce using rule 61 (expression -> expression LE expression .)
    &               reduce using rule 61 (expression -> expression LE expression .)
    ^               reduce using rule 61 (expression -> expression LE expression .)
    AND             reduce using rule 61 (expression -> expression LE expression .)
    OR              reduce using rule 61 (expression -> expression LE expression .)
    EQ              reduce using rule 61 (expression -> expression LE expression .)
    NEQ             reduce using rule 61 (expression -> expression LE expression .)
    >               reduce using rule 61 (expression -> expression LE expression .)
    <               reduce using rule 61 (expression -> expression LE expression .)
    LE              reduce using rule 61 (expression -> expression LE expression .)
    GE              reduce using rule 61 (expression -> expression LE expression .)
    ;               reduce using rule 61 (expression -> expression LE expression .)
    )               reduce using rule 61 (expression -> expression LE expression .)
    ,               reduce using rule 61 (expression -> expression LE expression .)
    +               shift and go to state 56
    -               shift and go to state 58
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52
    SHL             shift and go to state 55
    SHR             shift and go to state 50

  ! +               [ reduce using rule 61 (expression -> expression LE expression .) ]
  ! -               [ reduce using rule 61 (expression -> expression LE expression .) ]
  ! *               [ reduce using rule 61 (expression -> expression LE expression .) ]
  ! /               [ reduce using rule 61 (expression -> expression LE expression .) ]
  ! %               [ reduce using rule 61 (expression -> expression LE expression .) ]
  ! SHL             [ reduce using rule 61 (expression -> expression LE expression .) ]
  ! SHR             [ reduce using rule 61 (expression -> expression LE expression .) ]
  ! |               [ shift and go to state 66 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 60 ]
  ! EQ              [ shift and go to state 61 ]
  ! NEQ             [ shift and go to state 65 ]
  ! >               [ shift and go to state 62 ]
  ! <               [ shift and go to state 54 ]
  ! LE              [ shift and go to state 51 ]
  ! GE              [ shift and go to state 63 ]


state 93

    (49) expression -> expression % expression .
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    +               reduce using rule 49 (expression -> expression % expression .)
    -               reduce using rule 49 (expression -> expression % expression .)
    *               reduce using rule 49 (expression -> expression % expression .)
    /               reduce using rule 49 (expression -> expression % expression .)
    %               reduce using rule 49 (expression -> expression % expression .)
    |               reduce using rule 49 (expression -> expression % expression .)
    &               reduce using rule 49 (expression -> expression % expression .)
    ^               reduce using rule 49 (expression -> expression % expression .)
    AND             reduce using rule 49 (expression -> expression % expression .)
    OR              reduce using rule 49 (expression -> expression % expression .)
    SHL             reduce using rule 49 (expression -> expression % expression .)
    SHR             reduce using rule 49 (expression -> expression % expression .)
    EQ              reduce using rule 49 (expression -> expression % expression .)
    NEQ             reduce using rule 49 (expression -> expression % expression .)
    >               reduce using rule 49 (expression -> expression % expression .)
    <               reduce using rule 49 (expression -> expression % expression .)
    LE              reduce using rule 49 (expression -> expression % expression .)
    GE              reduce using rule 49 (expression -> expression % expression .)
    ;               reduce using rule 49 (expression -> expression % expression .)
    )               reduce using rule 49 (expression -> expression % expression .)
    ,               reduce using rule 49 (expression -> expression % expression .)

  ! +               [ shift and go to state 56 ]
  ! -               [ shift and go to state 58 ]
  ! *               [ shift and go to state 57 ]
  ! /               [ shift and go to state 59 ]
  ! %               [ shift and go to state 52 ]
  ! |               [ shift and go to state 66 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 60 ]
  ! SHL             [ shift and go to state 55 ]
  ! SHR             [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 61 ]
  ! NEQ             [ shift and go to state 65 ]
  ! >               [ shift and go to state 62 ]
  ! <               [ shift and go to state 54 ]
  ! LE              [ shift and go to state 51 ]
  ! GE              [ shift and go to state 63 ]


state 94

    (51) expression -> expression & expression .
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    |               reduce using rule 51 (expression -> expression & expression .)
    &               reduce using rule 51 (expression -> expression & expression .)
    ^               reduce using rule 51 (expression -> expression & expression .)
    AND             reduce using rule 51 (expression -> expression & expression .)
    OR              reduce using rule 51 (expression -> expression & expression .)
    ;               reduce using rule 51 (expression -> expression & expression .)
    )               reduce using rule 51 (expression -> expression & expression .)
    ,               reduce using rule 51 (expression -> expression & expression .)
    +               shift and go to state 56
    -               shift and go to state 58
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52
    SHL             shift and go to state 55
    SHR             shift and go to state 50
    EQ              shift and go to state 61
    NEQ             shift and go to state 65
    >               shift and go to state 62
    <               shift and go to state 54
    LE              shift and go to state 51
    GE              shift and go to state 63

  ! +               [ reduce using rule 51 (expression -> expression & expression .) ]
  ! -               [ reduce using rule 51 (expression -> expression & expression .) ]
  ! *               [ reduce using rule 51 (expression -> expression & expression .) ]
  ! /               [ reduce using rule 51 (expression -> expression & expression .) ]
  ! %               [ reduce using rule 51 (expression -> expression & expression .) ]
  ! SHL             [ reduce using rule 51 (expression -> expression & expression .) ]
  ! SHR             [ reduce using rule 51 (expression -> expression & expression .) ]
  ! EQ              [ reduce using rule 51 (expression -> expression & expression .) ]
  ! NEQ             [ reduce using rule 51 (expression -> expression & expression .) ]
  ! >               [ reduce using rule 51 (expression -> expression & expression .) ]
  ! <               [ reduce using rule 51 (expression -> expression & expression .) ]
  ! LE              [ reduce using rule 51 (expression -> expression & expression .) ]
  ! GE              [ reduce using rule 51 (expression -> expression & expression .) ]
  ! |               [ shift and go to state 66 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 60 ]


state 95

    (60) expression -> expression < expression .
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    |               reduce using rule 60 (expression -> expression < expression .)
    &               reduce using rule 60 (expression -> expression < expression .)
    ^               reduce using rule 60 (expression -> expression < expression .)
    AND             reduce using rule 60 (expression -> expression < expression .)
    OR              reduce using rule 60 (expression -> expression < expression .)
    EQ              reduce using rule 60 (expression -> expression < expression .)
    NEQ             reduce using rule 60 (expression -> expression < expression .)
    >               reduce using rule 60 (expression -> expression < expression .)
    <               reduce using rule 60 (expression -> expression < expression .)
    LE              reduce using rule 60 (expression -> expression < expression .)
    GE              reduce using rule 60 (expression -> expression < expression .)
    ;               reduce using rule 60 (expression -> expression < expression .)
    )               reduce using rule 60 (expression -> expression < expression .)
    ,               reduce using rule 60 (expression -> expression < expression .)
    +               shift and go to state 56
    -               shift and go to state 58
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52
    SHL             shift and go to state 55
    SHR             shift and go to state 50

  ! +               [ reduce using rule 60 (expression -> expression < expression .) ]
  ! -               [ reduce using rule 60 (expression -> expression < expression .) ]
  ! *               [ reduce using rule 60 (expression -> expression < expression .) ]
  ! /               [ reduce using rule 60 (expression -> expression < expression .) ]
  ! %               [ reduce using rule 60 (expression -> expression < expression .) ]
  ! SHL             [ reduce using rule 60 (expression -> expression < expression .) ]
  ! SHR             [ reduce using rule 60 (expression -> expression < expression .) ]
  ! |               [ shift and go to state 66 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 60 ]
  ! EQ              [ shift and go to state 61 ]
  ! NEQ             [ shift and go to state 65 ]
  ! >               [ shift and go to state 62 ]
  ! <               [ shift and go to state 54 ]
  ! LE              [ shift and go to state 51 ]
  ! GE              [ shift and go to state 63 ]


state 96

    (55) expression -> expression SHL expression .
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    |               reduce using rule 55 (expression -> expression SHL expression .)
    &               reduce using rule 55 (expression -> expression SHL expression .)
    ^               reduce using rule 55 (expression -> expression SHL expression .)
    AND             reduce using rule 55 (expression -> expression SHL expression .)
    OR              reduce using rule 55 (expression -> expression SHL expression .)
    SHL             reduce using rule 55 (expression -> expression SHL expression .)
    SHR             reduce using rule 55 (expression -> expression SHL expression .)
    EQ              reduce using rule 55 (expression -> expression SHL expression .)
    NEQ             reduce using rule 55 (expression -> expression SHL expression .)
    >               reduce using rule 55 (expression -> expression SHL expression .)
    <               reduce using rule 55 (expression -> expression SHL expression .)
    LE              reduce using rule 55 (expression -> expression SHL expression .)
    GE              reduce using rule 55 (expression -> expression SHL expression .)
    ;               reduce using rule 55 (expression -> expression SHL expression .)
    )               reduce using rule 55 (expression -> expression SHL expression .)
    ,               reduce using rule 55 (expression -> expression SHL expression .)
    +               shift and go to state 56
    -               shift and go to state 58
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52

  ! +               [ reduce using rule 55 (expression -> expression SHL expression .) ]
  ! -               [ reduce using rule 55 (expression -> expression SHL expression .) ]
  ! *               [ reduce using rule 55 (expression -> expression SHL expression .) ]
  ! /               [ reduce using rule 55 (expression -> expression SHL expression .) ]
  ! %               [ reduce using rule 55 (expression -> expression SHL expression .) ]
  ! |               [ shift and go to state 66 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 60 ]
  ! SHL             [ shift and go to state 55 ]
  ! SHR             [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 61 ]
  ! NEQ             [ shift and go to state 65 ]
  ! >               [ shift and go to state 62 ]
  ! <               [ shift and go to state 54 ]
  ! LE              [ shift and go to state 51 ]
  ! GE              [ shift and go to state 63 ]


state 97

    (45) expression -> expression + expression .
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    +               reduce using rule 45 (expression -> expression + expression .)
    -               reduce using rule 45 (expression -> expression + expression .)
    |               reduce using rule 45 (expression -> expression + expression .)
    &               reduce using rule 45 (expression -> expression + expression .)
    ^               reduce using rule 45 (expression -> expression + expression .)
    AND             reduce using rule 45 (expression -> expression + expression .)
    OR              reduce using rule 45 (expression -> expression + expression .)
    SHL             reduce using rule 45 (expression -> expression + expression .)
    SHR             reduce using rule 45 (expression -> expression + expression .)
    EQ              reduce using rule 45 (expression -> expression + expression .)
    NEQ             reduce using rule 45 (expression -> expression + expression .)
    >               reduce using rule 45 (expression -> expression + expression .)
    <               reduce using rule 45 (expression -> expression + expression .)
    LE              reduce using rule 45 (expression -> expression + expression .)
    GE              reduce using rule 45 (expression -> expression + expression .)
    ;               reduce using rule 45 (expression -> expression + expression .)
    )               reduce using rule 45 (expression -> expression + expression .)
    ,               reduce using rule 45 (expression -> expression + expression .)
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52

  ! *               [ reduce using rule 45 (expression -> expression + expression .) ]
  ! /               [ reduce using rule 45 (expression -> expression + expression .) ]
  ! %               [ reduce using rule 45 (expression -> expression + expression .) ]
  ! +               [ shift and go to state 56 ]
  ! -               [ shift and go to state 58 ]
  ! |               [ shift and go to state 66 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 60 ]
  ! SHL             [ shift and go to state 55 ]
  ! SHR             [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 61 ]
  ! NEQ             [ shift and go to state 65 ]
  ! >               [ shift and go to state 62 ]
  ! <               [ shift and go to state 54 ]
  ! LE              [ shift and go to state 51 ]
  ! GE              [ shift and go to state 63 ]


state 98

    (47) expression -> expression * expression .
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    +               reduce using rule 47 (expression -> expression * expression .)
    -               reduce using rule 47 (expression -> expression * expression .)
    *               reduce using rule 47 (expression -> expression * expression .)
    /               reduce using rule 47 (expression -> expression * expression .)
    %               reduce using rule 47 (expression -> expression * expression .)
    |               reduce using rule 47 (expression -> expression * expression .)
    &               reduce using rule 47 (expression -> expression * expression .)
    ^               reduce using rule 47 (expression -> expression * expression .)
    AND             reduce using rule 47 (expression -> expression * expression .)
    OR              reduce using rule 47 (expression -> expression * expression .)
    SHL             reduce using rule 47 (expression -> expression * expression .)
    SHR             reduce using rule 47 (expression -> expression * expression .)
    EQ              reduce using rule 47 (expression -> expression * expression .)
    NEQ             reduce using rule 47 (expression -> expression * expression .)
    >               reduce using rule 47 (expression -> expression * expression .)
    <               reduce using rule 47 (expression -> expression * expression .)
    LE              reduce using rule 47 (expression -> expression * expression .)
    GE              reduce using rule 47 (expression -> expression * expression .)
    ;               reduce using rule 47 (expression -> expression * expression .)
    )               reduce using rule 47 (expression -> expression * expression .)
    ,               reduce using rule 47 (expression -> expression * expression .)

  ! +               [ shift and go to state 56 ]
  ! -               [ shift and go to state 58 ]
  ! *               [ shift and go to state 57 ]
  ! /               [ shift and go to state 59 ]
  ! %               [ shift and go to state 52 ]
  ! |               [ shift and go to state 66 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 60 ]
  ! SHL             [ shift and go to state 55 ]
  ! SHR             [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 61 ]
  ! NEQ             [ shift and go to state 65 ]
  ! >               [ shift and go to state 62 ]
  ! <               [ shift and go to state 54 ]
  ! LE              [ shift and go to state 51 ]
  ! GE              [ shift and go to state 63 ]


state 99

    (46) expression -> expression - expression .
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    +               reduce using rule 46 (expression -> expression - expression .)
    -               reduce using rule 46 (expression -> expression - expression .)
    |               reduce using rule 46 (expression -> expression - expression .)
    &               reduce using rule 46 (expression -> expression - expression .)
    ^               reduce using rule 46 (expression -> expression - expression .)
    AND             reduce using rule 46 (expression -> expression - expression .)
    OR              reduce using rule 46 (expression -> expression - expression .)
    SHL             reduce using rule 46 (expression -> expression - expression .)
    SHR             reduce using rule 46 (expression -> expression - expression .)
    EQ              reduce using rule 46 (expression -> expression - expression .)
    NEQ             reduce using rule 46 (expression -> expression - expression .)
    >               reduce using rule 46 (expression -> expression - expression .)
    <               reduce using rule 46 (expression -> expression - expression .)
    LE              reduce using rule 46 (expression -> expression - expression .)
    GE              reduce using rule 46 (expression -> expression - expression .)
    ;               reduce using rule 46 (expression -> expression - expression .)
    )               reduce using rule 46 (expression -> expression - expression .)
    ,               reduce using rule 46 (expression -> expression - expression .)
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52

  ! *               [ reduce using rule 46 (expression -> expression - expression .) ]
  ! /               [ reduce using rule 46 (expression -> expression - expression .) ]
  ! %               [ reduce using rule 46 (expression -> expression - expression .) ]
  ! +               [ shift and go to state 56 ]
  ! -               [ shift and go to state 58 ]
  ! |               [ shift and go to state 66 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 60 ]
  ! SHL             [ shift and go to state 55 ]
  ! SHR             [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 61 ]
  ! NEQ             [ shift and go to state 65 ]
  ! >               [ shift and go to state 62 ]
  ! <               [ shift and go to state 54 ]
  ! LE              [ shift and go to state 51 ]
  ! GE              [ shift and go to state 63 ]


state 100

    (48) expression -> expression / expression .
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    +               reduce using rule 48 (expression -> expression / expression .)
    -               reduce using rule 48 (expression -> expression / expression .)
    *               reduce using rule 48 (expression -> expression / expression .)
    /               reduce using rule 48 (expression -> expression / expression .)
    %               reduce using rule 48 (expression -> expression / expression .)
    |               reduce using rule 48 (expression -> expression / expression .)
    &               reduce using rule 48 (expression -> expression / expression .)
    ^               reduce using rule 48 (expression -> expression / expression .)
    AND             reduce using rule 48 (expression -> expression / expression .)
    OR              reduce using rule 48 (expression -> expression / expression .)
    SHL             reduce using rule 48 (expression -> expression / expression .)
    SHR             reduce using rule 48 (expression -> expression / expression .)
    EQ              reduce using rule 48 (expression -> expression / expression .)
    NEQ             reduce using rule 48 (expression -> expression / expression .)
    >               reduce using rule 48 (expression -> expression / expression .)
    <               reduce using rule 48 (expression -> expression / expression .)
    LE              reduce using rule 48 (expression -> expression / expression .)
    GE              reduce using rule 48 (expression -> expression / expression .)
    ;               reduce using rule 48 (expression -> expression / expression .)
    )               reduce using rule 48 (expression -> expression / expression .)
    ,               reduce using rule 48 (expression -> expression / expression .)

  ! +               [ shift and go to state 56 ]
  ! -               [ shift and go to state 58 ]
  ! *               [ shift and go to state 57 ]
  ! /               [ shift and go to state 59 ]
  ! %               [ shift and go to state 52 ]
  ! |               [ shift and go to state 66 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 60 ]
  ! SHL             [ shift and go to state 55 ]
  ! SHR             [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 61 ]
  ! NEQ             [ shift and go to state 65 ]
  ! >               [ shift and go to state 62 ]
  ! <               [ shift and go to state 54 ]
  ! LE              [ shift and go to state 51 ]
  ! GE              [ shift and go to state 63 ]


state 101

    (54) expression -> expression OR expression .
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    OR              reduce using rule 54 (expression -> expression OR expression .)
    ;               reduce using rule 54 (expression -> expression OR expression .)
    )               reduce using rule 54 (expression -> expression OR expression .)
    ,               reduce using rule 54 (expression -> expression OR expression .)
    +               shift and go to state 56
    -               shift and go to state 58
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52
    |               shift and go to state 66
    &               shift and go to state 53
    ^               shift and go to state 67
    AND             shift and go to state 49
    SHL             shift and go to state 55
    SHR             shift and go to state 50
    EQ              shift and go to state 61
    NEQ             shift and go to state 65
    >               shift and go to state 62
    <               shift and go to state 54
    LE              shift and go to state 51
    GE              shift and go to state 63

  ! +               [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! -               [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! *               [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! /               [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! %               [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! |               [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! &               [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! ^               [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! SHL             [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! SHR             [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! EQ              [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! NEQ             [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! >               [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! <               [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! LE              [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! GE              [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! OR              [ shift and go to state 60 ]


state 102

    (57) expression -> expression EQ expression .
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    |               reduce using rule 57 (expression -> expression EQ expression .)
    &               reduce using rule 57 (expression -> expression EQ expression .)
    ^               reduce using rule 57 (expression -> expression EQ expression .)
    AND             reduce using rule 57 (expression -> expression EQ expression .)
    OR              reduce using rule 57 (expression -> expression EQ expression .)
    EQ              reduce using rule 57 (expression -> expression EQ expression .)
    NEQ             reduce using rule 57 (expression -> expression EQ expression .)
    >               reduce using rule 57 (expression -> expression EQ expression .)
    <               reduce using rule 57 (expression -> expression EQ expression .)
    LE              reduce using rule 57 (expression -> expression EQ expression .)
    GE              reduce using rule 57 (expression -> expression EQ expression .)
    ;               reduce using rule 57 (expression -> expression EQ expression .)
    )               reduce using rule 57 (expression -> expression EQ expression .)
    ,               reduce using rule 57 (expression -> expression EQ expression .)
    +               shift and go to state 56
    -               shift and go to state 58
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52
    SHL             shift and go to state 55
    SHR             shift and go to state 50

  ! +               [ reduce using rule 57 (expression -> expression EQ expression .) ]
  ! -               [ reduce using rule 57 (expression -> expression EQ expression .) ]
  ! *               [ reduce using rule 57 (expression -> expression EQ expression .) ]
  ! /               [ reduce using rule 57 (expression -> expression EQ expression .) ]
  ! %               [ reduce using rule 57 (expression -> expression EQ expression .) ]
  ! SHL             [ reduce using rule 57 (expression -> expression EQ expression .) ]
  ! SHR             [ reduce using rule 57 (expression -> expression EQ expression .) ]
  ! |               [ shift and go to state 66 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 60 ]
  ! EQ              [ shift and go to state 61 ]
  ! NEQ             [ shift and go to state 65 ]
  ! >               [ shift and go to state 62 ]
  ! <               [ shift and go to state 54 ]
  ! LE              [ shift and go to state 51 ]
  ! GE              [ shift and go to state 63 ]


state 103

    (59) expression -> expression > expression .
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    |               reduce using rule 59 (expression -> expression > expression .)
    &               reduce using rule 59 (expression -> expression > expression .)
    ^               reduce using rule 59 (expression -> expression > expression .)
    AND             reduce using rule 59 (expression -> expression > expression .)
    OR              reduce using rule 59 (expression -> expression > expression .)
    EQ              reduce using rule 59 (expression -> expression > expression .)
    NEQ             reduce using rule 59 (expression -> expression > expression .)
    >               reduce using rule 59 (expression -> expression > expression .)
    <               reduce using rule 59 (expression -> expression > expression .)
    LE              reduce using rule 59 (expression -> expression > expression .)
    GE              reduce using rule 59 (expression -> expression > expression .)
    ;               reduce using rule 59 (expression -> expression > expression .)
    )               reduce using rule 59 (expression -> expression > expression .)
    ,               reduce using rule 59 (expression -> expression > expression .)
    +               shift and go to state 56
    -               shift and go to state 58
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52
    SHL             shift and go to state 55
    SHR             shift and go to state 50

  ! +               [ reduce using rule 59 (expression -> expression > expression .) ]
  ! -               [ reduce using rule 59 (expression -> expression > expression .) ]
  ! *               [ reduce using rule 59 (expression -> expression > expression .) ]
  ! /               [ reduce using rule 59 (expression -> expression > expression .) ]
  ! %               [ reduce using rule 59 (expression -> expression > expression .) ]
  ! SHL             [ reduce using rule 59 (expression -> expression > expression .) ]
  ! SHR             [ reduce using rule 59 (expression -> expression > expression .) ]
  ! |               [ shift and go to state 66 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 60 ]
  ! EQ              [ shift and go to state 61 ]
  ! NEQ             [ shift and go to state 65 ]
  ! >               [ shift and go to state 62 ]
  ! <               [ shift and go to state 54 ]
  ! LE              [ shift and go to state 51 ]
  ! GE              [ shift and go to state 63 ]


state 104

    (62) expression -> expression GE expression .
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    |               reduce using rule 62 (expression -> expression GE expression .)
    &               reduce using rule 62 (expression -> expression GE expression .)
    ^               reduce using rule 62 (expression -> expression GE expression .)
    AND             reduce using rule 62 (expression -> expression GE expression .)
    OR              reduce using rule 62 (expression -> expression GE expression .)
    EQ              reduce using rule 62 (expression -> expression GE expression .)
    NEQ             reduce using rule 62 (expression -> expression GE expression .)
    >               reduce using rule 62 (expression -> expression GE expression .)
    <               reduce using rule 62 (expression -> expression GE expression .)
    LE              reduce using rule 62 (expression -> expression GE expression .)
    GE              reduce using rule 62 (expression -> expression GE expression .)
    ;               reduce using rule 62 (expression -> expression GE expression .)
    )               reduce using rule 62 (expression -> expression GE expression .)
    ,               reduce using rule 62 (expression -> expression GE expression .)
    +               shift and go to state 56
    -               shift and go to state 58
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52
    SHL             shift and go to state 55
    SHR             shift and go to state 50

  ! +               [ reduce using rule 62 (expression -> expression GE expression .) ]
  ! -               [ reduce using rule 62 (expression -> expression GE expression .) ]
  ! *               [ reduce using rule 62 (expression -> expression GE expression .) ]
  ! /               [ reduce using rule 62 (expression -> expression GE expression .) ]
  ! %               [ reduce using rule 62 (expression -> expression GE expression .) ]
  ! SHL             [ reduce using rule 62 (expression -> expression GE expression .) ]
  ! SHR             [ reduce using rule 62 (expression -> expression GE expression .) ]
  ! |               [ shift and go to state 66 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 60 ]
  ! EQ              [ shift and go to state 61 ]
  ! NEQ             [ shift and go to state 65 ]
  ! >               [ shift and go to state 62 ]
  ! <               [ shift and go to state 54 ]
  ! LE              [ shift and go to state 51 ]
  ! GE              [ shift and go to state 63 ]


state 105

    (58) expression -> expression NEQ expression .
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    |               reduce using rule 58 (expression -> expression NEQ expression .)
    &               reduce using rule 58 (expression -> expression NEQ expression .)
    ^               reduce using rule 58 (expression -> expression NEQ expression .)
    AND             reduce using rule 58 (expression -> expression NEQ expression .)
    OR              reduce using rule 58 (expression -> expression NEQ expression .)
    EQ              reduce using rule 58 (expression -> expression NEQ expression .)
    NEQ             reduce using rule 58 (expression -> expression NEQ expression .)
    >               reduce using rule 58 (expression -> expression NEQ expression .)
    <               reduce using rule 58 (expression -> expression NEQ expression .)
    LE              reduce using rule 58 (expression -> expression NEQ expression .)
    GE              reduce using rule 58 (expression -> expression NEQ expression .)
    ;               reduce using rule 58 (expression -> expression NEQ expression .)
    )               reduce using rule 58 (expression -> expression NEQ expression .)
    ,               reduce using rule 58 (expression -> expression NEQ expression .)
    +               shift and go to state 56
    -               shift and go to state 58
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52
    SHL             shift and go to state 55
    SHR             shift and go to state 50

  ! +               [ reduce using rule 58 (expression -> expression NEQ expression .) ]
  ! -               [ reduce using rule 58 (expression -> expression NEQ expression .) ]
  ! *               [ reduce using rule 58 (expression -> expression NEQ expression .) ]
  ! /               [ reduce using rule 58 (expression -> expression NEQ expression .) ]
  ! %               [ reduce using rule 58 (expression -> expression NEQ expression .) ]
  ! SHL             [ reduce using rule 58 (expression -> expression NEQ expression .) ]
  ! SHR             [ reduce using rule 58 (expression -> expression NEQ expression .) ]
  ! |               [ shift and go to state 66 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 60 ]
  ! EQ              [ shift and go to state 61 ]
  ! NEQ             [ shift and go to state 65 ]
  ! >               [ shift and go to state 62 ]
  ! <               [ shift and go to state 54 ]
  ! LE              [ shift and go to state 51 ]
  ! GE              [ shift and go to state 63 ]


state 106

    (50) expression -> expression | expression .
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    |               reduce using rule 50 (expression -> expression | expression .)
    AND             reduce using rule 50 (expression -> expression | expression .)
    OR              reduce using rule 50 (expression -> expression | expression .)
    ;               reduce using rule 50 (expression -> expression | expression .)
    )               reduce using rule 50 (expression -> expression | expression .)
    ,               reduce using rule 50 (expression -> expression | expression .)
    +               shift and go to state 56
    -               shift and go to state 58
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52
    &               shift and go to state 53
    ^               shift and go to state 67
    SHL             shift and go to state 55
    SHR             shift and go to state 50
    EQ              shift and go to state 61
    NEQ             shift and go to state 65
    >               shift and go to state 62
    <               shift and go to state 54
    LE              shift and go to state 51
    GE              shift and go to state 63

  ! +               [ reduce using rule 50 (expression -> expression | expression .) ]
  ! -               [ reduce using rule 50 (expression -> expression | expression .) ]
  ! *               [ reduce using rule 50 (expression -> expression | expression .) ]
  ! /               [ reduce using rule 50 (expression -> expression | expression .) ]
  ! %               [ reduce using rule 50 (expression -> expression | expression .) ]
  ! &               [ reduce using rule 50 (expression -> expression | expression .) ]
  ! ^               [ reduce using rule 50 (expression -> expression | expression .) ]
  ! SHL             [ reduce using rule 50 (expression -> expression | expression .) ]
  ! SHR             [ reduce using rule 50 (expression -> expression | expression .) ]
  ! EQ              [ reduce using rule 50 (expression -> expression | expression .) ]
  ! NEQ             [ reduce using rule 50 (expression -> expression | expression .) ]
  ! >               [ reduce using rule 50 (expression -> expression | expression .) ]
  ! <               [ reduce using rule 50 (expression -> expression | expression .) ]
  ! LE              [ reduce using rule 50 (expression -> expression | expression .) ]
  ! GE              [ reduce using rule 50 (expression -> expression | expression .) ]
  ! |               [ shift and go to state 66 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 60 ]


state 107

    (52) expression -> expression ^ expression .
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    |               reduce using rule 52 (expression -> expression ^ expression .)
    ^               reduce using rule 52 (expression -> expression ^ expression .)
    AND             reduce using rule 52 (expression -> expression ^ expression .)
    OR              reduce using rule 52 (expression -> expression ^ expression .)
    ;               reduce using rule 52 (expression -> expression ^ expression .)
    )               reduce using rule 52 (expression -> expression ^ expression .)
    ,               reduce using rule 52 (expression -> expression ^ expression .)
    +               shift and go to state 56
    -               shift and go to state 58
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52
    &               shift and go to state 53
    SHL             shift and go to state 55
    SHR             shift and go to state 50
    EQ              shift and go to state 61
    NEQ             shift and go to state 65
    >               shift and go to state 62
    <               shift and go to state 54
    LE              shift and go to state 51
    GE              shift and go to state 63

  ! +               [ reduce using rule 52 (expression -> expression ^ expression .) ]
  ! -               [ reduce using rule 52 (expression -> expression ^ expression .) ]
  ! *               [ reduce using rule 52 (expression -> expression ^ expression .) ]
  ! /               [ reduce using rule 52 (expression -> expression ^ expression .) ]
  ! %               [ reduce using rule 52 (expression -> expression ^ expression .) ]
  ! &               [ reduce using rule 52 (expression -> expression ^ expression .) ]
  ! SHL             [ reduce using rule 52 (expression -> expression ^ expression .) ]
  ! SHR             [ reduce using rule 52 (expression -> expression ^ expression .) ]
  ! EQ              [ reduce using rule 52 (expression -> expression ^ expression .) ]
  ! NEQ             [ reduce using rule 52 (expression -> expression ^ expression .) ]
  ! >               [ reduce using rule 52 (expression -> expression ^ expression .) ]
  ! <               [ reduce using rule 52 (expression -> expression ^ expression .) ]
  ! LE              [ reduce using rule 52 (expression -> expression ^ expression .) ]
  ! GE              [ reduce using rule 52 (expression -> expression ^ expression .) ]
  ! |               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 60 ]


state 108

    (38) compound_instr -> { anything_list } .

    }               reduce using rule 38 (compound_instr -> { anything_list } .)
    TYPE            reduce using rule 38 (compound_instr -> { anything_list } .)
    error           reduce using rule 38 (compound_instr -> { anything_list } .)
    PRINT           reduce using rule 38 (compound_instr -> { anything_list } .)
    ID              reduce using rule 38 (compound_instr -> { anything_list } .)
    IF              reduce using rule 38 (compound_instr -> { anything_list } .)
    WHILE           reduce using rule 38 (compound_instr -> { anything_list } .)
    REPEAT          reduce using rule 38 (compound_instr -> { anything_list } .)
    RETURN          reduce using rule 38 (compound_instr -> { anything_list } .)
    BREAK           reduce using rule 38 (compound_instr -> { anything_list } .)
    CONTINUE        reduce using rule 38 (compound_instr -> { anything_list } .)
    {               reduce using rule 38 (compound_instr -> { anything_list } .)
    (               reduce using rule 38 (compound_instr -> { anything_list } .)
    INTEGER         reduce using rule 38 (compound_instr -> { anything_list } .)
    FLOAT           reduce using rule 38 (compound_instr -> { anything_list } .)
    STRING          reduce using rule 38 (compound_instr -> { anything_list } .)
    $end            reduce using rule 38 (compound_instr -> { anything_list } .)
    UNTIL           reduce using rule 38 (compound_instr -> { anything_list } .)
    ELSE            reduce using rule 38 (compound_instr -> { anything_list } .)


state 109

    (8) declaration -> TYPE inits ; .

    UNTIL           reduce using rule 8 (declaration -> TYPE inits ; .)
    TYPE            reduce using rule 8 (declaration -> TYPE inits ; .)
    error           reduce using rule 8 (declaration -> TYPE inits ; .)
    PRINT           reduce using rule 8 (declaration -> TYPE inits ; .)
    ID              reduce using rule 8 (declaration -> TYPE inits ; .)
    IF              reduce using rule 8 (declaration -> TYPE inits ; .)
    WHILE           reduce using rule 8 (declaration -> TYPE inits ; .)
    REPEAT          reduce using rule 8 (declaration -> TYPE inits ; .)
    RETURN          reduce using rule 8 (declaration -> TYPE inits ; .)
    BREAK           reduce using rule 8 (declaration -> TYPE inits ; .)
    CONTINUE        reduce using rule 8 (declaration -> TYPE inits ; .)
    {               reduce using rule 8 (declaration -> TYPE inits ; .)
    (               reduce using rule 8 (declaration -> TYPE inits ; .)
    INTEGER         reduce using rule 8 (declaration -> TYPE inits ; .)
    FLOAT           reduce using rule 8 (declaration -> TYPE inits ; .)
    STRING          reduce using rule 8 (declaration -> TYPE inits ; .)
    }               reduce using rule 8 (declaration -> TYPE inits ; .)
    $end            reduce using rule 8 (declaration -> TYPE inits ; .)


state 110

    (10) inits -> inits , . init
    (12) init -> . ID = expression

    ID              shift and go to state 123

    init                           shift and go to state 122

state 111

    (71) fundef -> TYPE ID ( . args_list_or_empty ) compound_instr
    (72) args_list_or_empty -> . args_list
    (73) args_list_or_empty -> .
    (74) args_list -> . args_list , arg
    (75) args_list -> . arg
    (76) arg -> . TYPE ID

    )               reduce using rule 73 (args_list_or_empty -> .)
    TYPE            shift and go to state 127

    args_list_or_empty             shift and go to state 125
    arg                            shift and go to state 126
    args_list                      shift and go to state 124

state 112

    (12) init -> ID = . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    const                          shift and go to state 8
    expression                     shift and go to state 128

state 113

    (32) while_instr -> WHILE ( condition ) . instruction
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expression ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT anything_list UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { anything_list }
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    PRINT           shift and go to state 4
    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 5
    REPEAT          shift and go to state 15
    RETURN          shift and go to state 2
    BREAK           shift and go to state 14
    CONTINUE        shift and go to state 29
    {               shift and go to state 32
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    return_instr                   shift and go to state 7
    const                          shift and go to state 8
    assignment                     shift and go to state 17
    instruction                    shift and go to state 129
    compound_instr                 shift and go to state 19
    continue_instr                 shift and go to state 10
    labeled_instr                  shift and go to state 18
    print_instr                    shift and go to state 28
    choice_instr                   shift and go to state 3
    repeat_instr                   shift and go to state 6
    break_instr                    shift and go to state 24
    while_instr                    shift and go to state 11
    expression                     shift and go to state 30

state 114

    (33) while_instr -> WHILE ( error ) . instruction
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expression ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT anything_list UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { anything_list }
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    PRINT           shift and go to state 4
    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 5
    REPEAT          shift and go to state 15
    RETURN          shift and go to state 2
    BREAK           shift and go to state 14
    CONTINUE        shift and go to state 29
    {               shift and go to state 32
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    return_instr                   shift and go to state 7
    const                          shift and go to state 8
    assignment                     shift and go to state 17
    instruction                    shift and go to state 130
    compound_instr                 shift and go to state 19
    continue_instr                 shift and go to state 10
    while_instr                    shift and go to state 11
    print_instr                    shift and go to state 28
    choice_instr                   shift and go to state 3
    break_instr                    shift and go to state 24
    labeled_instr                  shift and go to state 18
    expression                     shift and go to state 30
    repeat_instr                   shift and go to state 6

state 115

    (34) repeat_instr -> REPEAT anything_list UNTIL condition . ;

    ;               shift and go to state 131


state 116

    (69) expr_list -> expr_list , . expression
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    ID              shift and go to state 34
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    expression                     shift and go to state 132
    const                          shift and go to state 8

state 117

    (65) expression -> ID ( expr_list_or_empty ) .

    +               reduce using rule 65 (expression -> ID ( expr_list_or_empty ) .)
    -               reduce using rule 65 (expression -> ID ( expr_list_or_empty ) .)
    *               reduce using rule 65 (expression -> ID ( expr_list_or_empty ) .)
    /               reduce using rule 65 (expression -> ID ( expr_list_or_empty ) .)
    %               reduce using rule 65 (expression -> ID ( expr_list_or_empty ) .)
    |               reduce using rule 65 (expression -> ID ( expr_list_or_empty ) .)
    &               reduce using rule 65 (expression -> ID ( expr_list_or_empty ) .)
    ^               reduce using rule 65 (expression -> ID ( expr_list_or_empty ) .)
    AND             reduce using rule 65 (expression -> ID ( expr_list_or_empty ) .)
    OR              reduce using rule 65 (expression -> ID ( expr_list_or_empty ) .)
    SHL             reduce using rule 65 (expression -> ID ( expr_list_or_empty ) .)
    SHR             reduce using rule 65 (expression -> ID ( expr_list_or_empty ) .)
    EQ              reduce using rule 65 (expression -> ID ( expr_list_or_empty ) .)
    NEQ             reduce using rule 65 (expression -> ID ( expr_list_or_empty ) .)
    >               reduce using rule 65 (expression -> ID ( expr_list_or_empty ) .)
    <               reduce using rule 65 (expression -> ID ( expr_list_or_empty ) .)
    LE              reduce using rule 65 (expression -> ID ( expr_list_or_empty ) .)
    GE              reduce using rule 65 (expression -> ID ( expr_list_or_empty ) .)
    ;               reduce using rule 65 (expression -> ID ( expr_list_or_empty ) .)
    )               reduce using rule 65 (expression -> ID ( expr_list_or_empty ) .)
    ,               reduce using rule 65 (expression -> ID ( expr_list_or_empty ) .)


state 118

    (66) expression -> ID ( error ) .

    +               reduce using rule 66 (expression -> ID ( error ) .)
    -               reduce using rule 66 (expression -> ID ( error ) .)
    *               reduce using rule 66 (expression -> ID ( error ) .)
    /               reduce using rule 66 (expression -> ID ( error ) .)
    %               reduce using rule 66 (expression -> ID ( error ) .)
    |               reduce using rule 66 (expression -> ID ( error ) .)
    &               reduce using rule 66 (expression -> ID ( error ) .)
    ^               reduce using rule 66 (expression -> ID ( error ) .)
    AND             reduce using rule 66 (expression -> ID ( error ) .)
    OR              reduce using rule 66 (expression -> ID ( error ) .)
    SHL             reduce using rule 66 (expression -> ID ( error ) .)
    SHR             reduce using rule 66 (expression -> ID ( error ) .)
    EQ              reduce using rule 66 (expression -> ID ( error ) .)
    NEQ             reduce using rule 66 (expression -> ID ( error ) .)
    >               reduce using rule 66 (expression -> ID ( error ) .)
    <               reduce using rule 66 (expression -> ID ( error ) .)
    LE              reduce using rule 66 (expression -> ID ( error ) .)
    GE              reduce using rule 66 (expression -> ID ( error ) .)
    ;               reduce using rule 66 (expression -> ID ( error ) .)
    )               reduce using rule 66 (expression -> ID ( error ) .)
    ,               reduce using rule 66 (expression -> ID ( error ) .)


state 119

    (27) assignment -> ID = expression ; .

    TYPE            reduce using rule 27 (assignment -> ID = expression ; .)
    error           reduce using rule 27 (assignment -> ID = expression ; .)
    PRINT           reduce using rule 27 (assignment -> ID = expression ; .)
    ID              reduce using rule 27 (assignment -> ID = expression ; .)
    IF              reduce using rule 27 (assignment -> ID = expression ; .)
    WHILE           reduce using rule 27 (assignment -> ID = expression ; .)
    REPEAT          reduce using rule 27 (assignment -> ID = expression ; .)
    RETURN          reduce using rule 27 (assignment -> ID = expression ; .)
    BREAK           reduce using rule 27 (assignment -> ID = expression ; .)
    CONTINUE        reduce using rule 27 (assignment -> ID = expression ; .)
    {               reduce using rule 27 (assignment -> ID = expression ; .)
    (               reduce using rule 27 (assignment -> ID = expression ; .)
    INTEGER         reduce using rule 27 (assignment -> ID = expression ; .)
    FLOAT           reduce using rule 27 (assignment -> ID = expression ; .)
    STRING          reduce using rule 27 (assignment -> ID = expression ; .)
    $end            reduce using rule 27 (assignment -> ID = expression ; .)
    UNTIL           reduce using rule 27 (assignment -> ID = expression ; .)
    }               reduce using rule 27 (assignment -> ID = expression ; .)
    ELSE            reduce using rule 27 (assignment -> ID = expression ; .)


state 120

    (28) choice_instr -> IF ( condition ) . instruction
    (29) choice_instr -> IF ( condition ) . instruction ELSE instruction
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expression ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT anything_list UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { anything_list }
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    PRINT           shift and go to state 4
    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 5
    REPEAT          shift and go to state 15
    RETURN          shift and go to state 2
    BREAK           shift and go to state 14
    CONTINUE        shift and go to state 29
    {               shift and go to state 32
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    return_instr                   shift and go to state 7
    const                          shift and go to state 8
    assignment                     shift and go to state 17
    instruction                    shift and go to state 133
    compound_instr                 shift and go to state 19
    continue_instr                 shift and go to state 10
    labeled_instr                  shift and go to state 18
    print_instr                    shift and go to state 28
    choice_instr                   shift and go to state 3
    repeat_instr                   shift and go to state 6
    break_instr                    shift and go to state 24
    while_instr                    shift and go to state 11
    expression                     shift and go to state 30

state 121

    (30) choice_instr -> IF ( error ) . instruction
    (31) choice_instr -> IF ( error ) . instruction ELSE instruction
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expression ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT anything_list UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { anything_list }
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    PRINT           shift and go to state 4
    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 5
    REPEAT          shift and go to state 15
    RETURN          shift and go to state 2
    BREAK           shift and go to state 14
    CONTINUE        shift and go to state 29
    {               shift and go to state 32
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    return_instr                   shift and go to state 7
    const                          shift and go to state 8
    assignment                     shift and go to state 17
    instruction                    shift and go to state 134
    compound_instr                 shift and go to state 19
    continue_instr                 shift and go to state 10
    while_instr                    shift and go to state 11
    print_instr                    shift and go to state 28
    choice_instr                   shift and go to state 3
    break_instr                    shift and go to state 24
    labeled_instr                  shift and go to state 18
    expression                     shift and go to state 30
    repeat_instr                   shift and go to state 6

state 122

    (10) inits -> inits , init .

    ;               reduce using rule 10 (inits -> inits , init .)
    ,               reduce using rule 10 (inits -> inits , init .)


state 123

    (12) init -> ID . = expression

    =               shift and go to state 112


state 124

    (72) args_list_or_empty -> args_list .
    (74) args_list -> args_list . , arg

    )               reduce using rule 72 (args_list_or_empty -> args_list .)
    ,               shift and go to state 135


state 125

    (71) fundef -> TYPE ID ( args_list_or_empty . ) compound_instr

    )               shift and go to state 136


state 126

    (75) args_list -> arg .

    ,               reduce using rule 75 (args_list -> arg .)
    )               reduce using rule 75 (args_list -> arg .)


state 127

    (76) arg -> TYPE . ID

    ID              shift and go to state 137


state 128

    (12) init -> ID = expression .
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    ;               reduce using rule 12 (init -> ID = expression .)
    ,               reduce using rule 12 (init -> ID = expression .)
    +               shift and go to state 56
    -               shift and go to state 58
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52
    |               shift and go to state 66
    &               shift and go to state 53
    ^               shift and go to state 67
    AND             shift and go to state 49
    OR              shift and go to state 60
    SHL             shift and go to state 55
    SHR             shift and go to state 50
    EQ              shift and go to state 61
    NEQ             shift and go to state 65
    >               shift and go to state 62
    <               shift and go to state 54
    LE              shift and go to state 51
    GE              shift and go to state 63


state 129

    (32) while_instr -> WHILE ( condition ) instruction .

    UNTIL           reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    TYPE            reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    error           reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    PRINT           reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    ID              reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    IF              reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    WHILE           reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    REPEAT          reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    RETURN          reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    BREAK           reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    CONTINUE        reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    {               reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    (               reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    INTEGER         reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    FLOAT           reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    STRING          reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    $end            reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    }               reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    ELSE            reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)


state 130

    (33) while_instr -> WHILE ( error ) instruction .

    UNTIL           reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    TYPE            reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    error           reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    PRINT           reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    ID              reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    IF              reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    WHILE           reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    REPEAT          reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    RETURN          reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    BREAK           reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    CONTINUE        reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    {               reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    (               reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    INTEGER         reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    FLOAT           reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    STRING          reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    $end            reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    }               reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    ELSE            reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)


state 131

    (34) repeat_instr -> REPEAT anything_list UNTIL condition ; .

    TYPE            reduce using rule 34 (repeat_instr -> REPEAT anything_list UNTIL condition ; .)
    error           reduce using rule 34 (repeat_instr -> REPEAT anything_list UNTIL condition ; .)
    PRINT           reduce using rule 34 (repeat_instr -> REPEAT anything_list UNTIL condition ; .)
    ID              reduce using rule 34 (repeat_instr -> REPEAT anything_list UNTIL condition ; .)
    IF              reduce using rule 34 (repeat_instr -> REPEAT anything_list UNTIL condition ; .)
    WHILE           reduce using rule 34 (repeat_instr -> REPEAT anything_list UNTIL condition ; .)
    REPEAT          reduce using rule 34 (repeat_instr -> REPEAT anything_list UNTIL condition ; .)
    RETURN          reduce using rule 34 (repeat_instr -> REPEAT anything_list UNTIL condition ; .)
    BREAK           reduce using rule 34 (repeat_instr -> REPEAT anything_list UNTIL condition ; .)
    CONTINUE        reduce using rule 34 (repeat_instr -> REPEAT anything_list UNTIL condition ; .)
    {               reduce using rule 34 (repeat_instr -> REPEAT anything_list UNTIL condition ; .)
    (               reduce using rule 34 (repeat_instr -> REPEAT anything_list UNTIL condition ; .)
    INTEGER         reduce using rule 34 (repeat_instr -> REPEAT anything_list UNTIL condition ; .)
    FLOAT           reduce using rule 34 (repeat_instr -> REPEAT anything_list UNTIL condition ; .)
    STRING          reduce using rule 34 (repeat_instr -> REPEAT anything_list UNTIL condition ; .)
    $end            reduce using rule 34 (repeat_instr -> REPEAT anything_list UNTIL condition ; .)
    UNTIL           reduce using rule 34 (repeat_instr -> REPEAT anything_list UNTIL condition ; .)
    }               reduce using rule 34 (repeat_instr -> REPEAT anything_list UNTIL condition ; .)
    ELSE            reduce using rule 34 (repeat_instr -> REPEAT anything_list UNTIL condition ; .)


state 132

    (69) expr_list -> expr_list , expression .
    (45) expression -> expression . + expression
    (46) expression -> expression . - expression
    (47) expression -> expression . * expression
    (48) expression -> expression . / expression
    (49) expression -> expression . % expression
    (50) expression -> expression . | expression
    (51) expression -> expression . & expression
    (52) expression -> expression . ^ expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression
    (55) expression -> expression . SHL expression
    (56) expression -> expression . SHR expression
    (57) expression -> expression . EQ expression
    (58) expression -> expression . NEQ expression
    (59) expression -> expression . > expression
    (60) expression -> expression . < expression
    (61) expression -> expression . LE expression
    (62) expression -> expression . GE expression

    ,               reduce using rule 69 (expr_list -> expr_list , expression .)
    )               reduce using rule 69 (expr_list -> expr_list , expression .)
    +               shift and go to state 56
    -               shift and go to state 58
    *               shift and go to state 57
    /               shift and go to state 59
    %               shift and go to state 52
    |               shift and go to state 66
    &               shift and go to state 53
    ^               shift and go to state 67
    AND             shift and go to state 49
    OR              shift and go to state 60
    SHL             shift and go to state 55
    SHR             shift and go to state 50
    EQ              shift and go to state 61
    NEQ             shift and go to state 65
    >               shift and go to state 62
    <               shift and go to state 54
    LE              shift and go to state 51
    GE              shift and go to state 63


state 133

    (28) choice_instr -> IF ( condition ) instruction .
    (29) choice_instr -> IF ( condition ) instruction . ELSE instruction

    TYPE            reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    error           reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    PRINT           reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    ID              reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    IF              reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    WHILE           reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    REPEAT          reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    RETURN          reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    BREAK           reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    CONTINUE        reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    {               reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    (               reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    INTEGER         reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    FLOAT           reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    STRING          reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    $end            reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    UNTIL           reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    }               reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    ELSE            shift and go to state 138

  ! ELSE            [ reduce using rule 28 (choice_instr -> IF ( condition ) instruction .) ]


state 134

    (30) choice_instr -> IF ( error ) instruction .
    (31) choice_instr -> IF ( error ) instruction . ELSE instruction

    TYPE            reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    error           reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    PRINT           reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    ID              reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    IF              reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    WHILE           reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    REPEAT          reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    RETURN          reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    BREAK           reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    CONTINUE        reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    {               reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    (               reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    INTEGER         reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    FLOAT           reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    STRING          reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    $end            reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    UNTIL           reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    }               reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    ELSE            shift and go to state 139

  ! ELSE            [ reduce using rule 30 (choice_instr -> IF ( error ) instruction .) ]


state 135

    (74) args_list -> args_list , . arg
    (76) arg -> . TYPE ID

    TYPE            shift and go to state 127

    arg                            shift and go to state 140

state 136

    (71) fundef -> TYPE ID ( args_list_or_empty ) . compound_instr
    (38) compound_instr -> . { anything_list }

    {               shift and go to state 32

    compound_instr                 shift and go to state 141

state 137

    (76) arg -> TYPE ID .

    ,               reduce using rule 76 (arg -> TYPE ID .)
    )               reduce using rule 76 (arg -> TYPE ID .)


state 138

    (29) choice_instr -> IF ( condition ) instruction ELSE . instruction
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expression ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT anything_list UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { anything_list }
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    PRINT           shift and go to state 4
    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 5
    REPEAT          shift and go to state 15
    RETURN          shift and go to state 2
    BREAK           shift and go to state 14
    CONTINUE        shift and go to state 29
    {               shift and go to state 32
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    return_instr                   shift and go to state 7
    const                          shift and go to state 8
    assignment                     shift and go to state 17
    instruction                    shift and go to state 142
    compound_instr                 shift and go to state 19
    continue_instr                 shift and go to state 10
    labeled_instr                  shift and go to state 18
    print_instr                    shift and go to state 28
    choice_instr                   shift and go to state 3
    repeat_instr                   shift and go to state 6
    break_instr                    shift and go to state 24
    while_instr                    shift and go to state 11
    expression                     shift and go to state 30

state 139

    (31) choice_instr -> IF ( error ) instruction ELSE . instruction
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expression ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT anything_list UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { anything_list }
    (43) expression -> . ID
    (44) expression -> . const
    (45) expression -> . expression + expression
    (46) expression -> . expression - expression
    (47) expression -> . expression * expression
    (48) expression -> . expression / expression
    (49) expression -> . expression % expression
    (50) expression -> . expression | expression
    (51) expression -> . expression & expression
    (52) expression -> . expression ^ expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . expression SHL expression
    (56) expression -> . expression SHR expression
    (57) expression -> . expression EQ expression
    (58) expression -> . expression NEQ expression
    (59) expression -> . expression > expression
    (60) expression -> . expression < expression
    (61) expression -> . expression LE expression
    (62) expression -> . expression GE expression
    (63) expression -> . ( expression )
    (64) expression -> . ( error )
    (65) expression -> . ID ( expr_list_or_empty )
    (66) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING

    PRINT           shift and go to state 4
    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 5
    REPEAT          shift and go to state 15
    RETURN          shift and go to state 2
    BREAK           shift and go to state 14
    CONTINUE        shift and go to state 29
    {               shift and go to state 32
    (               shift and go to state 9
    INTEGER         shift and go to state 13
    FLOAT           shift and go to state 1
    STRING          shift and go to state 16

    return_instr                   shift and go to state 7
    const                          shift and go to state 8
    assignment                     shift and go to state 17
    instruction                    shift and go to state 143
    compound_instr                 shift and go to state 19
    continue_instr                 shift and go to state 10
    while_instr                    shift and go to state 11
    print_instr                    shift and go to state 28
    choice_instr                   shift and go to state 3
    break_instr                    shift and go to state 24
    labeled_instr                  shift and go to state 18
    expression                     shift and go to state 30
    repeat_instr                   shift and go to state 6

state 140

    (74) args_list -> args_list , arg .

    ,               reduce using rule 74 (args_list -> args_list , arg .)
    )               reduce using rule 74 (args_list -> args_list , arg .)


state 141

    (71) fundef -> TYPE ID ( args_list_or_empty ) compound_instr .

    TYPE            reduce using rule 71 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    error           reduce using rule 71 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    PRINT           reduce using rule 71 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    ID              reduce using rule 71 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    IF              reduce using rule 71 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    WHILE           reduce using rule 71 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    REPEAT          reduce using rule 71 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    RETURN          reduce using rule 71 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    BREAK           reduce using rule 71 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    CONTINUE        reduce using rule 71 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    {               reduce using rule 71 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    (               reduce using rule 71 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    INTEGER         reduce using rule 71 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    FLOAT           reduce using rule 71 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    STRING          reduce using rule 71 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    $end            reduce using rule 71 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    UNTIL           reduce using rule 71 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    }               reduce using rule 71 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)


state 142

    (29) choice_instr -> IF ( condition ) instruction ELSE instruction .

    TYPE            reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    error           reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    PRINT           reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    ID              reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    IF              reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    WHILE           reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    REPEAT          reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    RETURN          reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    BREAK           reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    CONTINUE        reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    {               reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    (               reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    INTEGER         reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    FLOAT           reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    STRING          reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    $end            reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    UNTIL           reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    }               reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    ELSE            reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)


state 143

    (31) choice_instr -> IF ( error ) instruction ELSE instruction .

    TYPE            reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    error           reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    PRINT           reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    ID              reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    IF              reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    WHILE           reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    REPEAT          reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    RETURN          reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    BREAK           reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    CONTINUE        reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    {               reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    (               reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    INTEGER         reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    FLOAT           reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    STRING          reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    $end            reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    UNTIL           reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    }               reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    ELSE            reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)

